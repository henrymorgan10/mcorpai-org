<section id="care-canvas-game" aria-label="Love Children with Disabilities game" style="margin:24px auto;max-width:980px">
  <style>
    #care-canvas-game{font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;color:#0b1221}
    #care-canvas-game .wrap{position:relative;border:1px solid rgba(0,0,0,.08);border-radius:14px;background:#fff;box-shadow:0 10px 26px rgba(2,6,23,.06);padding:14px}
    #care-canvas-game h3{margin:0 0 8px;font-size:1rem;font-weight:800}
    #care-canvas-game .hud{display:flex;gap:12px;flex-wrap:wrap;align-items:baseline;color:#374151;font-size:.9rem;margin-bottom:8px}
    #care-canvas-game .hud b{color:#111827}
    #care-canvas-game canvas{width:100%;height:248px;display:block;border:1px solid #dbe6ff;border-radius:12px;background:linear-gradient(180deg,#eef4ff 0%,#ffffff 60%);position:relative;z-index:1}
    #care-canvas-game .controls{font-size:.86rem;color:#4b5563;margin-top:8px;min-height:36px;display:flex;align-items:center}
    #care-canvas-game .footer{margin-top:10px;text-align:center;color:#1e40af;font-size:.90rem}
    #care-canvas-game .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

    #ccg-banner{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(255,255,255,.96);border:1px solid #e5e7eb;border-radius:16px;padding:18px 22px;font-size:1.1rem;color:#0b1221;box-shadow:0 10px 24px rgba(2,6,23,.08);text-align:center;width:min(86%,560px);z-index:5;pointer-events:auto}
    #ccg-banner h4{margin:0 0 8px;font-size:1.25rem}
    #ccg-banner .start{display:inline-block;margin-top:8px;padding:8px 14px;border-radius:12px;border:1px solid #111827;background:#111827;color:#fff;font-weight:800;cursor:pointer}

    /* Toasts */
    #dad-toast{position:absolute;left:50%;top:12px;transform:translateX(-50%);background:rgba(255,255,255,.96);border:1px solid #e5e7eb;border-radius:12px;padding:10px 14px;font-size:1rem;color:#111827;box-shadow:0 10px 24px rgba(2,6,23,.08);z-index:4;display:none}
    #survival-msg{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(255,255,255,.96);border:1px solid #e5e7eb;border-radius:14px;padding:14px 18px;font-size:1.05rem;font-weight:800;color:#0b1221;box-shadow:0 10px 24px rgba(2,6,23,.08);z-index:4;display:none;text-align:center}
    #mission-pop{position:absolute;left:50%;top:18px;transform:translateX(-50%);background:rgba(14,21,38,.96);color:#fff;border:1px solid #0ea5e9;border-radius:12px;padding:10px 14px;font-size:.95rem;box-shadow:0 10px 24px rgba(2,6,23,.18);z-index:4;display:none}
    #game-toast{position:absolute;right:10px;top:10px;max-width:52%;background:rgba(17,24,39,.92);color:#f8fafc;border:1px solid rgba(148,163,184,.4);border-radius:12px;padding:8px 12px;font-size:.9rem;line-height:1.35;box-shadow:0 10px 22px rgba(2,6,23,.18);z-index:6;display:none}
    #game-toast b{color:#fbbf24}

    /* ===== Ending panel: inside the box, mouse-only to close/restart/exit ===== */
    #ccg-ending{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:min(92%,760px);background:#ffffff;border:1px solid #e5e7eb;border-radius:18px;box-shadow:0 18px 46px rgba(2,6,23,.18);padding:18px;display:none;z-index:20}
    #ccg-ending .ending-title{margin:0 0 6px;font:800 1.25rem/1.25 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#0b1221;text-align:center}
    #ccg-ending .ending-line{margin:2px 0 4px;font:700 1.05rem/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#111827;text-align:center}
    #ccg-ending .ending-sub{margin:0 10px 10px;font:.92rem/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#374151;text-align:center}
    #ccg-ending .ending-actions{display:flex;gap:10px;justify-content:center;align-items:center;margin-top:12px;flex-wrap:wrap}
    #ccg-ending .btn{display:inline-block;padding:9px 14px;border-radius:12px;border:1px solid #0f172a;background:#0f172a;color:#fff;text-decoration:none;font-weight:800;cursor:pointer}
    #ccg-ending .btn.gray{border-color:#d1d5db;background:#fff;color:#111827;font-weight:700}

    <!-- Copyright holder: https://mcorpai.org/ Gyu-min Jeon (also known as Morgan J.) -->

    @media (prefers-reduced-motion: reduce){ #care-canvas-game canvas{transition:none} }
  </style>

  <div class="wrap" role="group" aria-roledescription="game container">
    <h3 id="ccg-title"> ğŸ‘¨ Love Children with Disabilities ğŸŸ© No data is collected, Playable entirely offline ğŸ’Game size: 48KB </h3>
    <div class="hud" aria-live="polite">
      <div>Distance <b id="ccg-dist">0.0</b> m</div>
      <div>Care <b id="ccg-care">0</b></div>
      <div>Best Care <b id="ccg-best">0</b></div>
      <div>Stage <b id="ccg-stage">Day</b></div>
      <div>Combo <b id="ccg-combo">x1</b></div>
      <div>Mission <b id="ccg-mission">â€”</b></div>
      <div>Dash <b id="ccg-dash">Ready</b></div>
    </div>
    <div class="controls" id="ccg-controls">Click to start. Space for triple jump, hold to glide. X to dash. Enter converts obstacle. Collect ğŸ’, â¤, ğŸŒ to get bonuses. Rare â­ opens a 5s Golden Stage with no hazards.</div>
    <div style="position:relative">
      <canvas id="ccg-canvas" width="960" height="256" aria-label="Game canvas"></canvas>
      <div id="dad-toast" aria-live="polite"></div>
      <div id="survival-msg" aria-live="polite">You must collect the health bar to survive.</div>
      <div id="mission-pop" aria-live="polite"></div>
      <div id="game-toast" aria-live="polite"></div>
      <div id="ccg-banner" aria-live="polite">
        <h4>GAME START</h4>
        <div style="font-size:.95rem;color:#374151">Click anywhere on the canvas to begin. Space âœ¨ for triple jump, hold to glide ğŸª‚. X for dash âš¡. Collect ğŸ’â¤ for Care, ğŸŒ to slow time, â­ for Golden Stage.</div>
        <button class="start" id="ccg-start-btn" type="button">Start</button>
      </div>

      <!-- Ending panel (inside the box) -->
      <div id="ccg-ending" role="dialog" aria-modal="true" aria-live="polite">
        <h4 class="ending-title"> Nintendo Satoru Iwata, Directly to you! </h4>
        <p class="ending-line"> I will love you forever. </p>
        <p class="ending-sub"> Ideas over size. Love Children with Disabilities â€” Full PDF (260 pages)</p>
        <div class="ending-actions">
          <a class="btn" id="btn-open-pdf" href="https://mcorpai.org/Love%20Children%20with%20Disabilities(265%20Pages).pdf#view=FitH" target="_blank" rel="noopener">Open PDF</a>
          <button type="button" class="btn" id="btn-restart">Restart</button>
          <button type="button" class="btn gray" id="btn-exit">Exit Game</button>
        </div>
      </div>
    </div>
    <div id="ccg-live" class="sr-only" aria-live="polite"></div>
  </div>

  <div class="footer" id="ccg-footer"> Children with disabilities are covered under both the UNCRC and the CRPD as a cross-cutting rights-holder group. </div>

  <script>
  (function(){
    const canvas = document.getElementById('ccg-canvas');
    const ctx = canvas.getContext('2d');
    const banner = document.getElementById('ccg-banner');
    const startBtn = document.getElementById('ccg-start-btn');
    const dadToast = document.getElementById('dad-toast');
    const survivalMsg = document.getElementById('survival-msg');
    const missionPop = document.getElementById('mission-pop');
    const gameToast = document.getElementById('game-toast');
    const footerEl = document.getElementById('ccg-footer');
    const hudDist = document.getElementById('ccg-dist');
    const hudCare = document.getElementById('ccg-care');
    const hudBest = document.getElementById('ccg-best');
    const hudStage = document.getElementById('ccg-stage');
    const hudDash  = document.getElementById('ccg-dash');
    const hudCombo = document.getElementById('ccg-combo');
    const hudMission = document.getElementById('ccg-mission');
    const controlsEl = document.getElementById('ccg-controls');
    const endingPanel = document.getElementById('ccg-ending');
    const btnRestart = document.getElementById('btn-restart');
    const btnExit = document.getElementById('btn-exit');

    const rand = (a,b)=> Math.random()*(b-a)+a;
    const clamp=(v,a,b)=> Math.max(a, Math.min(b, v));
    const lerp=(a,b,t)=> a+(b-a)*t;

    // ===== Audio utils =====
    function makeAudio(srcs, volume, loop){
      const a = new Audio();
      a.preload = 'auto';
      a.crossOrigin = 'anonymous';
      a.loop = !!loop;
      a.volume = typeof volume==='number'? volume : 1;
      let i = 0;
      function next(){ if(i < srcs.length){ a.src = srcs[i++]; a.load(); } }
      a.addEventListener('error', ()=>{ next(); });
      next();
      return a;
    }

    // --- BGM: ëœë¤ ì¬ìƒ ì „ìš© ì˜¤ë””ì˜¤ (loop=false, íŠ¸ë™ ëë‚˜ë©´ ëœë¤ìœ¼ë¡œ ë‹¤ìŒ ê³¡)
    const TRACKS = [
      'https://mcorpai.org/Cherokee%20Shuffle.mp3',
      'https://mcorpai.org/Cumberland%20Gap.mp3',
      'https://mcorpai.org/Daisy%20Dukes.mp3',
      'https://mcorpai.org/Gold%20Bug%20Island.mp3',
      'https://mcorpai.org/Michigan%20Greens.mp3',
      "https://mcorpai.org/Reuben's%20Train.mp3",
      'https://mcorpai.org/adventuremusic.mp3'
    ];
    const bgm = new Audio();
    bgm.preload = 'auto';
    bgm.crossOrigin = 'anonymous';
    bgm.loop = false;
    bgm.volume = 0.42;
    let currentTrackIndex = -1;
    function pickNextTrack(){
      if(TRACKS.length===0) return null;
      let idx = Math.floor(Math.random()*TRACKS.length);
      if(TRACKS.length>1 && idx===currentTrackIndex){
        idx = (idx+1)%TRACKS.length;
      }
      currentTrackIndex = idx;
      return TRACKS[idx];
    }
    function playRandomTrack(){
      const src = pickNextTrack();
      if(!src) return;
      try{ bgm.src = src; bgm.currentTime = 0; bgm.load(); safePlay(bgm); }catch(e){}
    }
    bgm.addEventListener('ended', ()=>{ if(audioOn){ playRandomTrack(); } });

    // --- SFX (ì í”„)
    const jumpSfx = makeAudio([
      'https://mcorpai.org/jump6462.mp3',
      '/jump6462.mp3'
    ], 0.7, false);

    let audioOn = false; // ê²Œì„ ì¤‘ì—ë§Œ true

    function safePlay(a){ if(!audioOn) return; try{ const p=a.play(); if(p&&p.catch) p.catch(()=>{}); }catch(e){} }
    function stopAllAudio(){ try{ bgm.pause(); bgm.currentTime=0; }catch(e){} try{ jumpSfx.pause(); }catch(e){} }

    // Small toast helper
    let toastTimer=null; function toast(msg, sec=5){ gameToast.textContent=msg; gameToast.style.display='block'; if(toastTimer){ clearTimeout(toastTimer); toastTimer=null; } toastTimer=setTimeout(()=>{ gameToast.style.display='none'; }, Math.max(1000, sec*1000)); }

    const DEFAULT_HINT = 'Click to start. Space (triple) to jump, hold to glide, â†“ to duck, X to dash. Enter converts obstacle.';
    controlsEl.textContent = DEFAULT_HINT;

    // Best score
    const BEST_KEY='careCanvasBest_v14';
    let best=0; try{ best=parseInt(localStorage.getItem(BEST_KEY)||'0',10)||0; }catch(e){ best=0; }
    hudBest.textContent = best;

// Character (emoji)
const CHARS=[{w:26,h:30,draw:(x,y,duck)=>{ drawEmoji(x,y,duck?22:26, santaBlessTimer>0 ? 'ğŸ…' : 'ğŸ™‚'); }}];
    function drawEmoji(x,y,size,emoji){ ctx.font=`${size}px serif`; ctx.textBaseline='alphabetic'; ctx.fillText(emoji, x, y); }

    const RUPEE='ğŸ’', HEART='â¤', SNAIL='ğŸŒ', STAR='â­', HEALTH='ğŸŸ©', WHEEL='ğŸ¡';

    // World & physics
    const WORLD={w:canvas.width,h:canvas.height};
    const GROUND_Y = WORLD.h - 40;
    let running=false, paused=false;
    let tPrev=0; let gameTime=0; // seconds since start

    // Difficulty & speed (capped)
    let speed=220; const MAX_SPEED=540; let speedScale=1;

    let dist=0; let care=0; let spawnTimer=0; const gravity=1800; const baseJumpVy=560;

    // Time scale (for slowâ€‘mo)
    let slowmoTimer=0; const SLOWMO_FACTOR=0.4;

    // QTE director (now ~10% base chance)
    let qteActive=false, qteTimer=0, qteCooldown=0; const QTE_CHANCE=0.10; const QTE_COOLDOWN=4.0;

    // Speed growth
    let baseAccel = 6; let spikeTimer = 0; function scheduleSpike(){ spikeTimer = rand(4.5,8.0); } scheduleSpike();

    // Triple jump / glide
    const MAX_JUMPS = 3; const JUMP_CHAIN_WINDOW = 500; let jumpsUsed = 0; let lastPressTime = 0; let spaceHeld=false; let glideTime=0, MAX_GLIDE=0.35;

    // Dash (X key)
    let dashTimer=0; const DASH_DURATION=0.35; const DASH_COOLDOWN=2.5; let dashCooldown=0; let invulnTimer=0;

    // Support ability (Enter)
    let supportTimer=0, supportCooldown=1.2;

    const player={x:72,y:GROUND_Y,vy:0,duck:false,onGround:true};
    const hazards=[]; const pickups=[]; // rupees/hearts/snails/stars/health/wheel/revive

    // Hazard labels
    const SAFE_LABELS={ stairs:'Ramp', noise:'Quiet Zone', crowd:'Signage', block:'Safe Path' };
    const HAZARD_LABELS={ stairs:'Stairs', noise:'Noise', crowd:'Crowd', block:'Obstacle' };

    const TYPES=[ {key:'stairs',kind:'ground',w:40,h:24}, {key:'noise',kind:'air',w:48,h:16,y:96}, {key:'crowd',kind:'ground',w:42,h:22}, {key:'block',kind:'ground',w:30,h:26} ];
    const BOSSES=[ {key:'longNoise',kind:'air',w:200,h:16,y:92,label:'Loud Corridor'}, {key:'stairsWall',kind:'ground',w:160,h:30,label:'Steep Steps'}, {key:'crowdMass',kind:'ground',w:220,h:24,label:'Dense Crowd'} ];

  // ===== í—¬ê¸° ë³€ìˆ˜ (ìˆ˜ì •) =====
// ëª©í‘œ: â‘  ì•½ 20ì´ˆ ê°„ê²©ìœ¼ë¡œë§Œ ë“±ì¥(ì¡°ê¸ˆì˜ ì§€í„°), â‘¡ ë“±ì¥(=20ì´ˆ ê²½ê³¼)í•  ë•Œë§ˆë‹¤ í—¬ê¸° ì†ë„ ì†Œí­ ì¦ê°€
let heli = null;
let heliSpawnTimer = 0;

const HELI_MIN_DIST = 50;

// â¬‡ï¸ ìƒˆ íŒŒë¼ë¯¸í„°
const HELI_INTERVAL = 20;                   // ê¸°ë³¸ ê°„ê²©(ì´ˆ)
const HELI_JITTER   = 2;                    // ê°„ê²© ì§€í„°(Â±ì´ˆ)
const HELI_BASE_SPEED = 360;                // ì‹œì‘ ì†ë„(px/s)
const HELI_SPEED_STEP = 30;                 // 20ì´ˆë§ˆë‹¤(í•œ ë²ˆ ë“±ì¥í•  ë•Œë§ˆë‹¤) ì¦ê°€ëŸ‰
const HELI_MAX_SPEED  = 680;                // ìƒí•œì„ (ì„ íƒ)

let heliWave = 0;                           // ëª‡ ë²ˆì§¸ 20ì´ˆ/ë“±ì¥ ì‚¬ì´í´ì¸ì§€
let heliSpeed = HELI_BASE_SPEED;            // í˜„ì¬ ì‚¬ì´í´ì˜ í—¬ê¸° ê¸°ë³¸ì†ë„

function scheduleHeli(){
  // 20Â±2ì´ˆ ê°„ê²©ìœ¼ë¡œ ëŠìŠ¨í•˜ê²Œ ë“±ì¥
  heliSpawnTimer = rand(HELI_INTERVAL - HELI_JITTER, HELI_INTERVAL + HELI_JITTER);

  // ë‹¤ìŒ ë“±ì¥ì„ ìœ„í•œ â€˜ì›¨ì´ë¸Œâ€™ ì¦ê°€ì™€ ì†ë„ ê°±ì‹ 
  heliWave += 1;
  heliSpeed = Math.min(HELI_MAX_SPEED, HELI_BASE_SPEED + (heliWave - 1) * HELI_SPEED_STEP);
}


    // Stage cycle (Day/Night) every 50000(50km)
    let isDay=true; const STAGE_LEN=50000; function setStageText(){ hudStage.textContent = (goldenTimer>0? 'Golden' : (lonelyTimer>0? 'Dark' : (isDay? 'Day':'Night'))); }

    // Combo system
    let combo=0; let comboTimer=0; const COMBO_WINDOW=3.0; const MAX_MULT=5; function comboMult(){ return Math.min(MAX_MULT, 1 + Math.floor(combo/5)); }

    // Score multiplier from wheel
    let scoreMult=1, scoreMultTimer=0;

    // Random Mission system
    let mission=null; let missionGap=rand(16,28); // a bit rarer
    function setMissionText(){ hudMission.textContent = mission? mission.label : 'â€”'; }
    function showMission(text){ missionPop.textContent=text; missionPop.style.display='block'; setTimeout(()=>{ missionPop.style.display='none'; }, 1500); }
    function startRandomMission(){
      if(mission) return;
      const roll = Math.random();
      if(roll<0.5){ mission = {type:'hearts', label:'Get 3 Hearts in 30s', target:3, progress:0, timeLeft:30}; }
      else { mission = {type:'clear', label:'Clear 5 Obstacles in 20s', target:5, progress:0, timeLeft:20}; }
      setMissionText();
      showMission('Mission: ' + mission.label);
    }
    function finishMission(success){
      if(!mission) return;
      if(success){ award(20); invulnTimer = Math.max(invulnTimer, 3); toast('Mission complete. Reward applied.', 5); }
      else { toast('Mission failed. No penalty.', 5); }
      mission=null; setMissionText(); missionGap=rand(18,30);
    }

    // Info line
    let infoTimer=0; const INFO_DURATION=10; function showInfo(text){ controlsEl.textContent=text; infoTimer=INFO_DURATION; }

    // Golden stage
    let goldenTimer=0; const GOLDEN_DURATION=5; function startGolden(){ goldenTimer=GOLDEN_DURATION; hazards.length=0; toast('Golden Stage for 5s', 5); }

    // Wheel system
    function spinWheel(){ toast('Wheel spinningâ€¦', 2); setTimeout(()=>{ const r=Math.random(); if(r<0.25){ speed = Math.min(MAX_SPEED, speed + 120); toast('Wheel reward: Speed boost.', 5); } else if(r<0.5){ speedScale = 0.8; toast('Wheel reward: Smooth slowdown 3s.', 5); setTimeout(()=>{ speedScale=1; }, 3000); } else if(r<0.75){ invulnTimer = Math.max(invulnTimer, 2.5); toast('Wheel reward: Invulnerability 2.5s.', 5); } else { scoreMult = 2; scoreMultTimer = 6; toast('Wheel reward: Score x2 for 6s.', 5); } }, 2000); }

    // Snail (slow)
    let slowItemTimer=0; const SLOW_ITEM_FACTOR=0.7; const SLOW_ITEM_TIME=5;

// Effects
const fx=[]; function addFx(text,x,y,color){ fx.push({text,x,y,vy:-22,life:1,color}); }
let santaBlessTimer = 0; // 15s Santa blessing timer

    // Dad random events
// Dad random events
const DAD_CHOICES=[
  {key:'love', text:'I love you.Daddy is 50,000 meters away.'},
  {key:'hurt', text:'Listening to folk music, huh? Come eat.'},
  {key:'travel', text:"Dad is going on a long trip by helicopter."},
  {key:'santa', text:"Dad's coming today. Santa Claus said so."}
];    
    let dadEventTimer = rand(18,32); let dadMsgTimer = 0; let dadEffectPending = null; let dadBonusTimer = 0; let dadBonusFactor = 1; let lonelyTimer = 0; let lastDadAt = -999; const DAD_MIN_GAP=20;

    function triggerDadEvent(){
      if(!running || goldenTimer>0 || dadMsgTimer>0 || lonelyTimer>0) { dadEventTimer = rand(20,34); return; }
      if(gameTime - lastDadAt < DAD_MIN_GAP) { dadEventTimer = rand(10,16); return; }
      const c = DAD_CHOICES[Math.floor(Math.random()*DAD_CHOICES.length)];
      dadEffectPending = c.key; dadMsgTimer = 3; lastDadAt = gameTime;
      dadToast.textContent = `ğŸ‘¨ ${c.text}`; dadToast.style.display='block';
      dadEventTimer = rand(26,42);
    }

function applyDadEffect(){
  if(!dadEffectPending) return;
  if(dadEffectPending==='love'){
    speed = Math.min(MAX_SPEED, speed + 360);
    dadBonusFactor = 2.0; dadBonusTimer = 8; toast('Dad: bonus up for 8s.', 5);
  }
  else if(dadEffectPending==='hurt'){
    speed = Math.max(180, speed * 0.8);
    dadBonusFactor = 0.5; dadBonusTimer = 6; toast('Dad: slowdown and lower bonus for 6s.', 5);
  }
  else if(dadEffectPending==='travel'){
    lonelyTimer = 10; hazards.length=0; pickups.length=0; dadBonusFactor=1; dadBonusTimer=0; toast('Dad: dark 10s, no hazards or bonuses.', 5);
  }
  else if(dadEffectPending==='santa'){
    santaBlessTimer = 15;                 // 15ì´ˆ ë²„í”„ ì‹œì‘
    invulnTimer = Math.max(invulnTimer, 15); // 15ì´ˆ ì™„ì „ ë¬´ì 
    toast('Santa blessing: 15s invulnerability & survival freeze.', 5);
  }
  dadEffectPending=null; dadToast.style.display='none';
}

    <!-- Copyright holder: https://mcorpai.org/ Gyu-min Jeon (also known as Morgan J.) -->

    function award(points){ if(lonelyTimer>0) return; const add = Math.max(0, Math.floor(points * comboMult() * dadBonusFactor * scoreMult)); care += add; }

    // ===== Health survival =====
    let survivalTimer = 0; let survivalMsgTimer = 0; let healthSpawnTimer = 0;
    function difficulty01(){ return clamp(gameTime/120, 0, 1); }
    function scheduleHealthSpawn(){ const t = difficulty01(); const minI = lerp(1.4, 5.0, t); const maxI = lerp(3.0, 9.0, t); healthSpawnTimer = rand(minI, maxI); }
    function spawnHealth(dt){ healthSpawnTimer -= dt; if(healthSpawnTimer>0) return; const y = rand(GROUND_Y-110, GROUND_Y-70); pickups.push({x:WORLD.w+10,y,w:22,h:22,type:'health'}); scheduleHealthSpawn(); }

// ===== Revive & Lives system =====
let reviveStored = false;
let redTotal = 0;
let redNextThreshold = 10;
let hardLevel = 0;
let hardSpikeTimer = 0;

// Lives / healthâ€‘pickup ì¹´ìš´íŠ¸ (ì´ˆë³´ììš©)
let lives = 1;                // ê¸°ë³¸ ëª©ìˆ¨ 1
const MAX_LIVES = 2;          // ìµœëŒ€ ëª©ìˆ¨ 2
let healthPickupCount = 0;    // ğŸŸ© í”½ì—… ëˆ„ì  ì¹´ìš´íŠ¸
const HEALTHS_FOR_LIFE = 10;  // ğŸŸ© 10ê°œ ë‹¹ ëª©ìˆ¨ +1

    
function useRevive(reason){
  reviveStored = false;
  invulnTimer = Math.max(invulnTimer, 2.5);
  // ê·¼ì²˜ ì¥ì• ë¬¼ ì•ˆì „ ì²˜ë¦¬
  for(const h of hazards){
    const cx = h.x + h.w * 0.5;
    if(Math.abs(cx - (player.x + 14)) < 90) h.safe = true;
  }
  // HEALTH ì•„ì´í…œê³¼ ì¼ê´€ë˜ê²Œ 20ì´ˆë¡œ ë³µêµ¬
  if(reason === 'survival'){
    survivalTimer = 20;
  }
  addFx('Revive âœš', player.x+6, player.y-50, '#ef4444');
  toast('Revived once. Charge consumed.', 5);
}
    function maybeHardSpike(){
      if(redTotal >= redNextThreshold){
        hardLevel += 1; hardSpikeTimer = 12;
        redNextThreshold += 10;
        toast('Difficulty spike! Red squares reached '+(redNextThreshold-10)+'.', 5);
      } else {
        const remain = redNextThreshold - redTotal;
        toast('Revive ready. '+redTotal+'/'+(redNextThreshold- (redNextThreshold%10?redNextThreshold%10:0) || 10)+' toward hard spike. '+remain+' to go.', 5);
      }
    }

    // ===== ì´ˆë³´ì ì™„í™”ìš© ë³´ì • (ì´ˆë°˜ 25ì´ˆë§Œ, ì ì§„ ì†Œë©¸) =====
    let beginnerGrace = true; // ì²« ì¶©ëŒ 1íšŒ ìë™ ì„¸ì´ë¸Œ
    function beginnerEase(){ return clamp(1 - gameTime/25, 0, 1); } // 0~25s ë™ì•ˆ 1â†’0ìœ¼ë¡œ ê°ì†Œ

     function spawn(dt){
      if(lonelyTimer>0){ spawnTimer=0.2; return; }

// spawn(dt) ë‚´ë¶€ â€” í—¬ê¸° ìŠ¤í° ë¡œì§ (ìˆ˜ì •)
// ë³€ê²½ì : 20ì´ˆ ì£¼ê¸° ìŠ¤ì¼€ì¤„ ì‚¬ìš© + ìŠ¤í° ì‹œì ì˜ ì†ë„ë¥¼ ê° í—¬ê¸° ê°ì²´ì— ë°•ì œ(heli.speed)
heliSpawnTimer -= dt;
if(dist >= HELI_MIN_DIST && !heli){
  if(heliSpawnTimer <= 0){
    // í•­ìƒ í”Œë ˆì´ì–´ ì•ìª½(ìš°ì¸¡)ì—ì„œë§Œ ë“±ì¥. ì ‘ê·¼ ë†’ì´ì™€ ì•½ê°„ì˜ ì˜¤í”„ì…‹ì„ ëœë¤.
    const hy = rand(GROUND_Y - 160, GROUND_Y - 80);
    const xOffset = rand(0, 48);
    heli = {
      x: WORLD.w + 12 + xOffset,
      y: hy,
      w: 34,
      h: 22,
      type: 'heli',
      dir: 'left',
      speed: heliSpeed        // â¬…ï¸ ì´ë²ˆ ì‚¬ì´í´ì˜ ê³ ìœ  ì†ë„ ì €ì¥
    };
    scheduleHeli();           // â¬…ï¸ ë‹¤ìŒ 20ì´ˆ ê°„ê²© ì˜ˆì•½ + ì†ë„ ë‹¨ê³„ ê°±ì‹ 
  }
}


      spawnTimer -= dt; if(spawnTimer>0) return;

      const timeDf = clamp(gameTime/240, 0, 1);
      let hazardChance = 0.60 + 0.18*timeDf + 0.06*hardLevel + (hardSpikeTimer>0?0.18:0);
      let bossChance   = 0.10 + 0.08*timeDf + 0.03*hardLevel + (hardSpikeTimer>0?0.06:0);

      // ì´ˆë³´ì ì™„í™”: ì´ˆë°˜ì—” ì¶œí˜„ìœ¨ê³¼ ë³´ìŠ¤ìœ¨ì„ ë‚®ì¶¤
      const ease = beginnerEase();
      hazardChance *= (1 - 0.25*ease);
      bossChance   *= (1 - 0.40*ease);
      hazardChance = Math.min(0.9, hazardChance);

      if(goldenTimer>0){ const type = Math.random()<0.2? HEART : RUPEE; const y = rand(GROUND_Y-110, GROUND_Y-40); pickups.push({x:WORLD.w+10,y,w:20,h:20,type: type==='ğŸ’'? 'rupee':'heart'}); spawnTimer = rand(0.15,0.35); return; }

      let MAX_HAZARDS = 9 + Math.min(3, hardLevel);
      MAX_HAZARDS -= Math.round(2*ease); // ì´ˆë°˜ì—” ë™ì‹œì¥ì• ë¬¼ 1~2ê°œ ì¤„ì„
      const wantHazard = Math.random() < hazardChance && hazards.length<MAX_HAZARDS;

      if(wantHazard){
        if(Math.random()<bossChance){ const b=BOSSES[Math.floor(Math.random()*BOSSES.length)]; const y=b.kind==='ground'?(GROUND_Y-b.h):(b.y||92); hazards.push({x:WORLD.w+10,y,w:b.w,h:b.h,type:b.key,kind:b.kind,label:b.label,safe:false,boss:true}); spawnTimer=2.6; return; }
        const t=TYPES[Math.floor(Math.random()*TYPES.length)]; const y=t.kind==='ground'?(GROUND_Y-t.h):(t.y||90); const label=HAZARD_LABELS[t.key]; hazards.push({x:WORLD.w+10,y,w:t.w,h:t.h,type:t.key,kind:t.kind,label,safe:false,boss:false});
      } else {
        const roll = Math.random();
        if(roll<0.46){ const y= GROUND_Y-60; pickups.push({x:WORLD.w+10,y,w:20,h:20,type:'rupee'}); }
        else if(roll<0.77){ const y= GROUND_Y-90; pickups.push({x:WORLD.w+10,y,w:20,h:20,type:'heart'}); }
        else if(roll<0.88){ const y= GROUND_Y-30; pickups.push({x:WORLD.w+10,y,w:20,h:20,type:'snail'}); }
        else if(roll<0.93){ const y= GROUND_Y-80; pickups.push({x:WORLD.w+10,y,w:22,h:22,type:'star'}); }
        else if(roll<0.96){ const y= GROUND_Y-70; pickups.push({x:WORLD.w+10,y,w:18,h:18,type:'revive',box:true}); }
        else { const y= GROUND_Y-70; pickups.push({x:WORLD.w+10,y,w:22,h:22,type:'wheel'}); }
      }

      const effectiveSpeed = speed * speedScale;
      let MIN_SPAWN = 0.55 - 0.11*timeDf - 0.04*hardLevel - (hardSpikeTimer>0?0.10:0);
      MIN_SPAWN = Math.max(0.30, MIN_SPAWN);
      const base = rand(0.9,1.6)*(220/Math.max(220,effectiveSpeed));
      spawnTimer = Math.max(MIN_SPAWN, base);
    }

    function transformNearest(){ if(supportTimer>0) return; let target=null, minDx=1e9; for(const h of hazards){ if(h.safe) continue; const dx=h.x-player.x; if(dx>=-24 && dx<160 && dx<minDx){minDx=dx; target=h;} } if(!target) return; if(target.boss){ for(const h of hazards){ const near=Math.abs((h.x+h.w*0.5)-(target.x+target.w*0.5))<target.w*0.8; if(!h.safe && near) h.safe=true; } } else { target.safe=true; } award(1); supportTimer=supportCooldown; try{ if(care>best){ best=care; localStorage.setItem(BEST_KEY,String(best)); hudBest.textContent=best; } }catch(e){}
    }

    // Special counters
    let rupeeCount=0, heartCount=0; let shieldTimer=0; const SHIELD_TIME=4;

    function update(dt){
      gameTime += dt;

      // Dad events
      dadEventTimer -= dt; if(dadEventTimer<=0){ triggerDadEvent(); }
      if(dadMsgTimer>0){ dadMsgTimer -= dt; if(dadMsgTimer<=0){ applyDadEffect(); } }
      if(dadBonusTimer>0){ dadBonusTimer -= dt; if(dadBonusTimer<=0){ dadBonusFactor=1; }}
      if(lonelyTimer>0){ lonelyTimer -= dt; }

      // Missions
      if(!mission){ missionGap -= dt; if(missionGap<=0){ startRandomMission(); } }
      else { mission.timeLeft -= dt; if(mission.timeLeft<=0){ finishMission(false); } }

       // Survival
  survivalMsgTimer -= dt; if(survivalMsgTimer<=0 && survivalMsg.style.display!=='none'){ survivalMsg.style.display='none'; }
  if (santaBlessTimer<=0) survivalTimer -= dt; // ì‚°íƒ€ 15ì´ˆ ë™ì•ˆ ìƒì¡´ íƒ€ì´ë¨¸ ì •ì§€
  if(survivalTimer<=0){ if(reviveStored){ useRevive('survival'); } else { endGame(); return; } }
  spawnHealth(dt);
  // Santa timer down
  if (santaBlessTimer>0) santaBlessTimer -= dt;

      // Time scale
      const scale = (slowmoTimer>0)? SLOWMO_FACTOR : 1; const edt = dt*scale; if(slowmoTimer>0){ slowmoTimer -= dt; }

      // QTE (ì´ˆë³´ì ì™„í™”: ë°œë™ ê±°ë¦¬/ì‹œê°„ ì‚´ì§ ì¦ê°€)
      if(!qteActive && qteCooldown<=0 && invulnTimer<=0 && goldenTimer<=0){
        const {dx} = nearestHazardDx();
        const ease = beginnerEase();
        const qteRange = 34 + 10*ease; // ì´ˆë°˜ 34â†’44í”½ì…€
        if(dx>0 && dx<qteRange && Math.random()<QTE_CHANCE){ qteActive=true; qteTimer=0.6 + 0.15*ease; slowmoTimer = Math.max(slowmoTimer, 1.0); addFx('QTE!', player.x+4, player.y-52, '#2563eb'); }
      }
      if(qteActive){ qteTimer -= dt; if(qteTimer<=0){ qteActive=false; qteCooldown=QTE_COOLDOWN; } }
      if(qteCooldown>0){ qteCooldown-=dt; }

      // Score multiplier decay
      if(scoreMultTimer>0){ scoreMultTimer -= dt; if(scoreMultTimer<=0){ scoreMult=1; }}

      // Speed & spikes (ì´ˆë³´ì ì™„í™”: ì´ˆë°˜ ê°€ì†ì„ ì•½ 35%ê¹Œì§€ ê²½ê°)
      const t = clamp(speed/MAX_SPEED, 0, 1);
      let accel = (baseAccel + hardLevel*1.2) * (1 - t);
      const ease = beginnerEase();
      accel *= (1 - 0.35*ease);
      if(hardSpikeTimer>0){ accel += 0.8; hardSpikeTimer -= dt; speed = Math.min(MAX_SPEED, speed + 120*edt); }
      if(slowItemTimer>0){ slowItemTimer -= dt; if(slowItemTimer<=0){ speedScale=1; } }
      speed = Math.min(MAX_SPEED, speed + accel*edt);
      spikeTimer -= edt; if(spikeTimer<=0 && goldenTimer<=0){ speed = Math.min(MAX_SPEED, speed + rand(8,26)*edt); scheduleSpike(); }

      if(infoTimer>0){ infoTimer-=dt; if(infoTimer<=0){ controlsEl.textContent = DEFAULT_HINT; }}

      // timers
      if(dashCooldown>0){ dashCooldown-=edt; if(dashCooldown<0) dashCooldown=0; }
      if(dashTimer>0){ dashTimer-=edt; invulnTimer=Math.max(invulnTimer, dashTimer); speed = Math.min(MAX_SPEED, speed + 360*edt); }
      if(invulnTimer>0){ invulnTimer-=edt; }
      if(shieldTimer>0){ shieldTimer-=edt; }
      if(comboTimer>0){ comboTimer-=edt; if(comboTimer<=0){ combo=0; }}
      if(goldenTimer>0){ goldenTimer-=dt; if(goldenTimer<=0){ toast('Golden ended.', 3); }}

      // gravity with glide
      let effectiveG = gravity; if(!player.onGround && spaceHeld && glideTime>0){ effectiveG = gravity*0.36; glideTime -= edt; if(glideTime<0) glideTime=0; }
      player.vy += -effectiveG*edt; player.y += -player.vy*edt;
      if(player.y>=GROUND_Y){ player.y=GROUND_Y; player.vy=0; if(!player.onGround){ jumpsUsed=0; glideTime=MAX_GLIDE; } player.onGround=true; } else { player.onGround=false; }

            const v = speed * speedScale;
      for(let i=hazards.length-1;i>=0;i--){ const h=hazards[i]; h.x -= v*edt; if(!h.passed && h.x+h.w<player.x){ h.passed=true; if(mission && mission.type==='clear'){ mission.progress++; setMissionText(); if(mission.progress>=mission.target){ finishMission(true); } } } if(h.x+h.w<-20) hazards.splice(i,1); }
      for(let i=pickups.length-1;i>=0;i--){ const p=pickups[i]; p.x -= v*edt; if(p.x+p.w<-20 || p.y>WORLD.h+40) pickups.splice(i,1); }

// update(dt) ë‚´ë¶€ â€” í—¬ê¸° ì´ë™ (ìˆ˜ì •)
// ë³€ê²½ì : ì „ì—­ ìƒìˆ˜ HELI_SPEED ì‚¬ìš© â†’ ê°œë³„ ê°ì²´ì˜ heli.speed ì‚¬ìš©
if(heli){
  const heliVel = (heli.speed + speed*0.05);  // â¬…ï¸ ê²Œì„ ì§„í–‰ì†ë„ ë³´ì • ë¹„ì¤‘ ì•½ê°„ ë‚®ì¶¤
  heli.x -= heliVel * edt;

  // ìì—°ìŠ¤ëŸ° ìƒí•˜ í”ë“¤ë¦¼ ìœ ì§€
  if(!heli._jit){ heli._jit = { t: 0, amp: rand(2, 8) }; }
  heli._jit.t += edt;
  heli.y += Math.sin(heli._jit.t * 4) * (heli._jit.amp * 0.02);

  if(heli.x + heli.w < -20){
    heli = null;
  }
}


      for(let i=fx.length-1;i>=0;i--){ const f=fx[i]; f.y += f.vy*edt; f.life -= edt; if(f.life<=0) fx.splice(i,1); }

      dist += v*edt*0.01;

      const stageIndex = Math.floor(dist/STAGE_LEN)%2; const shouldBeDay = stageIndex===0; if(shouldBeDay!==isDay && goldenTimer<=0 && lonelyTimer<=0){ isDay=shouldBeDay; }
      setStageText();

      hudDash.textContent = dashCooldown>0 ? 'Cooling' : 'Ready';
      hudCombo.textContent = 'x'+comboMult();
      if(mission){ hudMission.textContent = `${mission.label}  [${mission.progress}/${mission.target}]  ${Math.max(0,mission.timeLeft).toFixed(0)}s`; }
    }

    function collide(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

       function check(){
      const c=CHARS[0]; const ph = player.duck? c.h*0.6 : c.h; const p={x:player.x+2,y:player.y-ph+2,w:Math.max(18,c.w-4),h:Math.max(18,ph-4)};

      // í—¬ê¸° ì¦‰ì‚¬ ì²´í¬: í—¬ê¸°ê°€ ì¡´ì¬í•˜ê³  ì¶©ëŒí•˜ë©´ ë¬´ì¡°ê±´ ê²Œì„ ì˜¤ë²„
      if(heli && collide(p, heli)){
        // í—¬ê¸° ì¶©ëŒì€ ì¦‰ì‚¬ ì²˜ë¦¬(ëª©ìˆ¨ ë¬´ì‹œ)
        return true;
      }

      // hazards
for(const h of hazards){ if(h.safe) continue; if(collide(p,h)){
    if(invulnTimer>0 || shieldTimer>0){ h.safe=true; continue; }
    // ì´ˆë³´ì ê·¸ë ˆì´ìŠ¤: ì´ˆë°˜ 25ì´ˆ ë‚´ ì²« ì¶©ëŒ 1íšŒ ìë™ ì„¸ì´ë¸Œ
    if(beginnerGrace && beginnerEase()>0){ beginnerGrace=false; h.safe=true; invulnTimer=Math.max(invulnTimer,1.5); addFx('Grace âœš', player.x+6, player.y-50, '#10b981'); toast('Beginner grace consumed.', 4); continue; }
    if(reviveStored){ h.safe=true; useRevive('hit'); continue; }
    // Livesê°€ ìˆìœ¼ë©´ ëª©ìˆ¨ì„ ì†Œëª¨í•˜ê³  ì¦‰ì‹œ ë¬´ì /ê·¼ì ‘ ì¥ì• ë¬¼ ì•ˆì „ì²˜ë¦¬
    if(lives > 1){
      lives -= 1;
      invulnTimer = Math.max(invulnTimer, 2.5);
      for(const hh of hazards){ const cx=hh.x+hh.w*0.5; if(Math.abs(cx - (player.x+14)) < 90) hh.safe=true; }
      addFx('Life âˆ’1', player.x+6, player.y-50, '#ef4444');
      toast('Life lost. Lives: ' + lives, 4);
      const livesEl = document.getElementById('ccg-lives'); if(livesEl) livesEl.textContent = String(lives);
      continue; // ê²Œì„ ê³„ì†
    }
    // ë” ì´ìƒ ëª©ìˆ¨ì´ ì—†ìœ¼ë©´ ê²Œì„ ì˜¤ë²„ë¡œ ì²˜ë¦¬
    return true;
} }
      // pickups
      for(let i=pickups.length-1;i>=0;i--){ const a=pickups[i]; const box={x:a.x,y:a.y,w:a.w,h:a.h}; if(collide(p,box)){
          combo += 1; comboTimer = COMBO_WINDOW;
          if(a.type==='rupee'){
            rupeeCount+=1; award(1); if(rupeeCount>=10){ shieldTimer = SHIELD_TIME; rupeeCount=0; toast('Shield on for 4s.', 5); }
          } else if(a.type==='heart'){
            heartCount+=1; award(2);
            if(mission && mission.type==='hearts'){ mission.progress++; setMissionText(); if(mission.progress>=mission.target){ finishMission(true); } }
            if(heartCount>=3){ for(const h of hazards){ h.safe=true; } heartCount=0; toast('Field Clear.', 3); }
          } else if(a.type==='snail'){
            slowItemTimer = SLOW_ITEM_TIME; speedScale = SLOW_ITEM_FACTOR; toast('Slow down for 5s.', 5);
          } else if(a.type==='star'){
            startGolden();
 } else if(a.type === 'health'){
  // ìƒì¡´ íƒ€ì´ë¨¸ íšŒë³µ: +20ì´ˆ, ìµœëŒ€ 20ì´ˆ
  survivalTimer = Math.min(20, survivalTimer + 20);
  addFx('+SURVIVE', player.x + 6, player.y - 40, '#10b981');
  award(1);

  // HEALTH í”½ì—… ëˆ„ì : HEALTHS_FOR_LIFE(10)ê°œë§ˆë‹¤ ì¶”ê°€ ëª©ìˆ¨ ì§€ê¸‰ (ìµœëŒ€ MAX_LIVES)
  healthPickupCount += 1;
  if(healthPickupCount >= HEALTHS_FOR_LIFE){
    healthPickupCount -= HEALTHS_FOR_LIFE;
    if(lives < MAX_LIVES){
      lives += 1;
      const livesEl = document.getElementById('ccg-lives'); if(livesEl) livesEl.textContent = String(lives);
      toast('Extra life gained! Lives: ' + lives, 4);
    }
  }
}else if(a.type==='wheel'){
            spinWheel();
          } else if(a.type==='revive'){
            redTotal += 1;
            if(!reviveStored){ reviveStored = true; toast('Red square stored. 1 revive ready.', 5); }
            maybeHardSpike();
          }

          // ===== Total Score add per item (blue) =====
          if(a.type==='rupee' || a.type==='heart' || a.type==='snail' || a.type==='star' || a.type==='health' || a.type==='wheel'){
            updateTotalScore(ITEM_POINTS[a.type]||0);
          }

          pickups.splice(i,1);
          try{ if(care>best){ best=care; localStorage.setItem(BEST_KEY,String(best)); hudBest.textContent=best; } }catch(e){}
      } }
      return false;
    }

    function draw(){
      if(lonelyTimer>0){ ctx.fillStyle='#0b1221'; }
      else if(goldenTimer>0){ ctx.fillStyle='#fff7d6'; }
      else if(isDay){ ctx.fillStyle='#eaf2ff'; } else { ctx.fillStyle='#0b1221'; }
      ctx.fillRect(0,0,WORLD.w,WORLD.h);
      ctx.fillStyle=(goldenTimer>0)? '#f0cc4a' : (isDay? '#cfe0ff' : '#172033'); ctx.fillRect(0, GROUND_Y+12, WORLD.w, 2);

      const c=CHARS[0]; c.draw(player.x, player.y-2, player.duck);

      if(dadMsgTimer>0 || dadBonusTimer>0 || lonelyTimer>0){ const ex=Math.min(WORLD.w-36, player.x+48); const ey=Math.max(28, player.y-70); drawEmoji(ex, ey, 28, 'ğŸ‘¨'); }

      if(qteActive){ ctx.font='bold 14px system-ui'; ctx.fillStyle = '#2563eb'; ctx.fillText('QTE', player.x-6, player.y-58); }

      if(shieldTimer>0){ ctx.strokeStyle = isDay? '#22c55e' : '#a7f3d0'; if(goldenTimer>0) ctx.strokeStyle='#f59e0b'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(player.x+14, player.y-18, 18, 0, Math.PI*2); ctx.stroke(); }

      ctx.font='12px system-ui';
      for(const h of hazards){ ctx.fillStyle = h.safe? '#34d399' : '#fca5a5'; ctx.fillRect(h.x, h.y, h.w, h.h); ctx.fillStyle=(goldenTimer>0)? '#b45309' : (isDay? '#0b1221':'#dbeafe'); if(h.label) ctx.fillText(h.label, h.x+4, Math.max(12,h.y-2)); if(h.safe){ const key=h.type; const text= key==='longNoise'? SAFE_LABELS['noise'] : key==='stairsWall'? SAFE_LABELS['stairs'] : key==='crowdMass'? SAFE_LABELS['crowd'] : SAFE_LABELS[key]||''; if(text) ctx.fillText(text, h.x+4, h.y+h.h+12); } }

         for(const p of pickups){ if(p.box){
          ctx.fillStyle = '#ef4444'; ctx.fillRect(p.x-9, p.y-18, 18, 18);
          ctx.strokeStyle = isDay? '#fee2e2' : '#fecaca'; ctx.strokeRect(p.x-9, p.y-18, 18, 18);
        } else {
          ctx.font='18px serif'; ctx.fillStyle = (goldenTimer>0)? '#b45309' : (isDay? '#111' : '#fff');
          const ch = p.type==='rupee'?RUPEE : p.type==='heart'? HEART : p.type==='snail'? SNAIL : p.type==='star'? STAR : p.type==='health'? HEALTH : p.type==='wheel'? WHEEL : 'â€¢';
          ctx.fillText(ch, p.x, p.y);
        }
      }

// í—¬ê¸° ë Œë”ë§
if(heli){
  // ë°©í–¥ì— ë”°ë¼ í—¬ê¸° ì•„ì´ì½˜ì˜ ê¸°ë³¸ ìœ„ì¹˜ë¥¼ ì¡°ì •
  // drawEmojiëŠ” ì´ë¯¸ ì •ì˜ëœ í•¨ìˆ˜ì…ë‹ˆë‹¤. í•„ìš” ì‹œ ê¸€ì í¬ê¸°(size) ì¡°ì •í•˜ì„¸ìš”.
  // y ìœ„ì¹˜ì— heli.hë¥¼ ë”í•´ ë°”ë‹¥ ê¸°ì¤€ìœ¼ë¡œ ì ì ˆíˆ ë³´ì´ë„ë¡ í•©ë‹ˆë‹¤.
  drawEmoji(heli.x, heli.y + heli.h, 26, 'ğŸš');
}
  // íƒ€ì´ë¨¸ 15ì´ˆ
      if(survivalTimer<=15){ ctx.font='bold 16px system-ui'; ctx.fillStyle = (isDay? '#b91c1c':'#fecaca'); ctx.fillText(`Find ${HEALTH}! ${survivalTimer.toFixed(1)}s`, WORLD.w*0.5-60, 22); }
      for(const f of fx){ ctx.globalAlpha = Math.max(0,f.life); ctx.fillStyle = f.color || '#111827'; ctx.font='bold 14px system-ui'; ctx.fillText(f.text, f.x, f.y); ctx.globalAlpha=1; }

      hudDist.textContent = dist.toFixed(1);
      hudCare.textContent = care;
    }

    function loop(ts){ if(!running){ tPrev=ts; return; } let dt=Math.min(0.033,(ts-tPrev)/1000||0); tPrev=ts; if(!paused){ spawn(dt); update(dt); if(check()){ endGame(); return; } draw(); } requestAnimationFrame(loop); }

  // ===== Ending helpers =====
let endingTimer=null; let endingOpen=false;
const endingLineEl = endingPanel.querySelector('.ending-line');

function clearEndingTimer(){
  if(endingTimer){ clearTimeout(endingTimer); endingTimer=null; }
}

// reason: 'score' | 'timer' | 'gameover' | undefined
function showEnding(reason){
  // ê¸°ë³¸(íƒ€ì´ë¨¸/ê²Œì„ì˜¤ë²„ ë“±) ë¬¸êµ¬
  let line = 'I will love you forever.';
  // 50,000ì  ì—”ë”©ë§Œ ë³„ë„ ë¬¸êµ¬
  if(reason === 'score'){
    line = "My father will never return. But thatâ€™s alright â€” I still have Santa Claus. He told me that when I grow up, my father will come back to me.";
  }
  if(endingLineEl) endingLineEl.textContent = line;

  endingPanel.style.display='block';
  endingOpen=true;
  audioOn=false; // ì—”ë”©ì—ì„  ì¦‰ì‹œ ì •ì§€
  stopAllAudio();
}

    <!-- Copyright holder: https://mcorpai.org/ Gyu-min Jeon (also known as Morgan J.) -->

function hideEnding(){ endingPanel.style.display='none'; endingOpen=false; }
function endByTimer(){ running=false; paused=false; showEnding('timer'); }
    
    function resetToStartScreen(){
      // ê²Œì„ ë£¨í”„ ì •ì§€ ë° UI ì´ˆê¸°ìƒíƒœ
      running=false; paused=false; clearEndingTimer(); hideEnding(); stopAllAudio(); audioOn=false;
      banner.style.display='block';
      const title = banner.querySelector('h4'); if(title) title.textContent='GAME START';
      controlsEl.textContent = DEFAULT_HINT;
      canvas.style.visibility='visible';
    }

function startGame(){
  running=true; paused=false; speed=220; speedScale=1; dist=0; care=0; hazards.length=0; pickups.length=0; player.y=GROUND_Y; player.vy=0; player.duck=false; spawnTimer=0.2; combo=0; comboTimer=0; rupeeCount=0; heartCount=0; goldenTimer=0; slowItemTimer=0; dadEventTimer = rand(18,32); dadMsgTimer=0; dadEffectPending=null; dadBonusTimer=0; dadBonusFactor=1; lonelyTimer=0; gameTime=0; lastDadAt=-999; setStageText(); mission=null; missionGap=rand(16,28); setMissionText(); banner.style.display='none'; dadToast.style.display='none';
  // survival ì´ˆê¸°ê°’ (ìš”êµ¬ì‚¬í•­: 15ì´ˆë¡œ í†µì¼)
  survivalTimer = 15; survivalMsgTimer = 3; survivalMsg.textContent = 'You must collect the health bar to survive.'; survivalMsg.style.display = 'block';

  scheduleHealthSpawn(); qteActive=false; qteCooldown=0; scoreMult=1; scoreMultTimer=0;
  reviveStored=false; redTotal=0; redNextThreshold=10; hardLevel=0; hardSpikeTimer=0; beginnerGrace=true;
  // Lives ì´ˆê¸°í™”
  lives = 1; healthPickupCount = 0; // reset health pickup counter
  // í—¬ê¸° ì´ˆê¸°í™” ë° íƒ€ì´ë¨¸ ìŠ¤ì¼€ì¤„
// startGame() ì¼ë¶€ â€” ì´ˆê¸°í™” (ìˆ˜ì •)
// ë³€ê²½ì : ì›¨ì´ë¸Œ/ì†ë„ ì´ˆê¸°í™” í›„ ìŠ¤ì¼€ì¤„ ì‹œì‘
// ...
heli = null;
heliWave = 0;
heliSpeed = HELI_BASE_SPEED;
scheduleHeli();

  // â˜… ì¤‘ìš”: ì‚°íƒ€ ì¶•ë³µ íƒ€ì´ë¨¸ ì´ˆê¸°í™”
  santaBlessTimer = 0; // ì‹œì‘ ì§í›„ ğŸ… í‘œì‹œ ë°©ì§€

  // HUDì— ë°˜ì˜
  const livesEl = document.getElementById('ccg-lives'); if(livesEl) livesEl.textContent = String(lives);
  hideEnding(); clearEndingTimer();
  audioOn=true; try{ playRandomTrack(); }catch(e){}
  requestAnimationFrame((t)=>{tPrev=t; requestAnimationFrame(loop);});
  endingTimer = setTimeout(endByTimer, 12000000)
}

    function endGame(){ running=false; paused=false; banner.style.display='block'; banner.querySelector('h4').textContent='GAME OVER'; dadToast.style.display='none'; survivalMsg.style.display='none'; mission=null; setMissionText(); clearEndingTimer(); showEnding(); try{ if(care>best){ best=care; localStorage.setItem(BEST_KEY,String(best)); hudBest.textContent=best; } }catch(e){}; footerEl.textContent='Please support mcorpai.org'; }

    function performJump(mult=1){ const jumpVy = baseJumpVy * mult; player.vy = jumpVy; player.onGround=false; safePlay(jumpSfx); }

    function nearestHazardDx(){ let dxMin=1e9, target=null; for(const h of hazards){ if(h.safe) continue; const dx=h.x - player.x; if(dx>=-10 && dx<dxMin){ dxMin=dx; target=h; } } return {dx:dxMin, target}; }

    function onSpacePress(){ const now = performance.now(); if(!running){ startGame(); return; } if(now - lastPressTime <= JUMP_CHAIN_WINDOW){ /* keep chain */ } lastPressTime = now; if(player.onGround) { jumpsUsed = 0; glideTime=MAX_GLIDE; } const {dx} = nearestHazardDx(); if(dx>0 && dx<36 && player.onGround){ award(3); addFx('Perfect! âœ¨', player.x+6, player.y-40, '#f59e0b'); } if(jumpsUsed < MAX_JUMPS){ const mult = (jumpsUsed===0)? 1 : (jumpsUsed===1? 0.92 : 0.86); performJump(mult); jumpsUsed += 1; } }

    function tryDash(){ if(!running) return; if(dashCooldown>0) return; dashTimer = DASH_DURATION; invulnTimer = Math.max(invulnTimer, DASH_DURATION); dashCooldown = DASH_COOLDOWN; const {dx, target} = nearestHazardDx(); if(dx>0 && dx<80){ slowmoTimer = Math.max(slowmoTimer, 1.0); addFx('Sloâ€‘mo! ğŸ•’', player.x+2, player.y-50, '#2563eb'); if(qteActive && target){ target.safe=true; award(4); qteActive=false; qteCooldown=QTE_COOLDOWN; toast('QTE success. Nearest obstacle cleared.', 5); } } }

    // === Input handlers ===
    function onKeyDown(e){
      const active=document.activeElement&&['INPUT','TEXTAREA','SELECT'].includes(document.activeElement.tagName);
      if(active) return;
      // ì—”ë”©ì°½ì´ ì—´ë ¤ ìˆìœ¼ë©´ ëª¨ë“  í‚¤ ì…ë ¥ ë¬´ì‹œ (ëª¨ë°”ì¼ í•˜ë“œì›¨ì–´ í‚¤ í¬í•¨)
      if(endingOpen){ if(['Space','Enter','KeyX','ArrowDown','KeyP'].includes(e.code)){ e.preventDefault(); return; } }
      if(['ArrowDown','Space','Enter','KeyX'].includes(e.code)) e.preventDefault();
      if(e.code==='Space'){ spaceHeld=true; onSpacePress(); }
      else if(e.key==='ArrowDown'){ if(running) player.duck=true; }
      else if(e.key==='Enter'){ if(running) transformNearest(); }
      else if(e.code==='KeyX'){ tryDash(); }
      else if(e.code==='KeyP'){ if(running) paused=!paused; }
    }
    function onKeyUp(e){ if(e.code==='Space') spaceHeld=false; if(e.key==='ArrowDown') player.duck=false; }

    // í´ë¦­/í„°ì¹˜: ì—”ë”©ì°½ ì˜¤í”ˆ ì‹œì—ëŠ” ìº”ë²„ìŠ¤/ë°°ë„ˆ ì…ë ¥ ë¬´ì‹œ
    canvas.addEventListener('click', ()=>{ if(endingOpen) return; if(!running){ startGame(); } else { onSpacePress(); } });
    if(startBtn){ startBtn.addEventListener('click', (ev)=>{ if(endingOpen) return; ev.stopPropagation(); startGame(); }); }
    banner.addEventListener('click', (ev)=>{ if(endingOpen) return; ev.stopPropagation(); startGame(); });

    if(btnRestart){ btnRestart.addEventListener('click', ()=>{ hideEnding(); startGame(); }); }
    if(btnExit){ btnExit.addEventListener('click', ()=>{ resetToStartScreen(); }); }

    let touchStart=0, lastTap=0;
    canvas.addEventListener('touchstart', (e)=>{ if(endingOpen){ e.preventDefault(); return; } const now=performance.now(); if(!running){ startGame(); return; } const rect=canvas.getBoundingClientRect(); const x=e.touches[0].clientX-rect.left; const left=x<rect.width*0.45; if(now-lastTap<260 && left){ transformNearest(); lastTap=0; return; } lastTap=now; touchStart=now; player.duck=true; }, {passive:true});
    canvas.addEventListener('touchend', (e)=>{ if(endingOpen){ e.preventDefault(); return; } if(!running) return; const dur=performance.now()-touchStart; if(dur<180){ onSpacePress(); } player.duck=false; }, {passive:true});

    window.addEventListener('keydown', onKeyDown); window.addEventListener('keyup', onKeyUp);
    window.addEventListener('blur', ()=>{ if(running) paused=true; }); window.addEventListener('focus', ()=>{ if(running) paused=false; });

    /* ========================
       Addâ€‘on: Total Score HUD + Item Scoring + 2,000 step difficulty + 50,000 ending
       (ì›ë³¸ ë¡œì§ì€ ë³€ê²½í•˜ì§€ ì•Šê³ , ë™ì¼ ìŠ¤ì½”í”„ ë‚´ì—ì„œ í™•ì¥)
    =========================*/
  const hudEl = document.querySelector('#care-canvas-game .hud');
// Lives HUD (ì˜ì–´, ë¹¨ê°„ìƒ‰)
const lifeWrap = document.createElement('div');
lifeWrap.style.color = 'red';
lifeWrap.innerHTML = 'Lives <b id="ccg-lives" style="color:red">1</b>';
// Total score (ê¸°ì¡´)
const totalWrap = document.createElement('div');
totalWrap.style.color = '#2563eb';
totalWrap.innerHTML = 'total score(50,000 ending) <b id="ccg-total" style="color:#2563eb">0</b>';
// ì‚½ì…: lifeWrapì„ ë¨¼ì € ë„£ê³  totalWrapì„ ê·¸ ë‹¤ìŒì— ë‘¡ë‹ˆë‹¤.
if(hudEl && hudEl.firstChild){ hudEl.insertBefore(lifeWrap, hudEl.firstChild); hudEl.insertBefore(totalWrap, lifeWrap.nextSibling); } else if(hudEl){ hudEl.appendChild(lifeWrap); hudEl.appendChild(totalWrap); }

    

    let totalScore = 0;
    const SCORE_STEP = 2000;
    const SCORE_ENDING = 50000;
    let nextStep = SCORE_STEP;

    const ITEM_POINTS = { rupee:10, heart:20, snail:30, star:40, health:50, wheel:60 };

    function updateScoreHud(){ const el=document.getElementById('ccg-total'); if(el) el.textContent = String(totalScore); }

function updateTotalScore(delta){
  if(!delta) return;
  totalScore += delta;
  updateScoreHud();
  while(totalScore >= nextStep){
    speed = Math.min(MAX_SPEED, speed + 20);
    toast('Difficulty increased!', 3);
    nextStep += SCORE_STEP;
  }
  if(totalScore >= SCORE_ENDING){
    running=false; paused=false; showEnding('score'); // ì ìˆ˜ ì—”ë”©ë§Œ íŠ¹ë³„ ë¬¸êµ¬
  }
}
<!-- Copyright holder: https://mcorpai.org/ Gyu-min Jeon (also known as Morgan J.) -->

    // startGame í™•ì¥: ì ìˆ˜ ì´ˆê¸°í™”
    const __startGame = startGame;
    startGame = function(){ totalScore=0; nextStep=SCORE_STEP; updateScoreHud(); return __startGame(); };

    // check í™•ì¥: í”½ì—…ë³„ total score ë°˜ì˜ ë³´ê°•
    const __check = check;
    check = function(){
      const result = __check.apply(this, arguments);
      // ë§¤ í”„ë ˆì„ í”Œë ˆì´ì–´ì™€ ê°€ê¹Œìš´ í”½ì—…ì„ ì¬ê²€ì‚¬í•˜ì—¬ ì ìˆ˜ë§Œ ë³„ë„ë¡œ ë°˜ì˜
      const c=CHARS[0]; const ph = player.duck? c.h*0.6 : c.h; const p={x:player.x+2,y:player.y-ph+2,w:Math.max(18,c.w-4),h:Math.max(18,ph-4)};
      for(let i=pickups.length-1;i>=0;i--){ const a=pickups[i]; if(!a || a.box) continue; const box={x:a.x,y:a.y,w:a.w,h:a.h}; if(collide(p,box)){
          if(ITEM_POINTS[a.type]){ updateTotalScore(ITEM_POINTS[a.type]); }
      } }
      return result;
    };

  })();
  </script>
</section>

