<!-- 
=== AI game Start === 

ÏïÑÎûò Ï≤®Î∂ÄÌååÏùº Ïù¥ÎØ∏ÏßÄÏóê Í≤ÄÏùÄÏÉâ Î∂ÄÎ∂ÑÏóê PDF ÎßÅÌÅ¨ Ï≤®Î∂ÄÌï†Î†§Í≥† ÌïòÎäîÎç∞(Í∞ÄÏö¥Îç∞ Ï†ïÎ†¨) Ïñ¥ÎîîÏóêÎã§ ÏΩîÎìúÎ•º ÎÑ£Ïñ¥ÏïºÎèº? ÏúÑÏπòÎ•º ÏÉÅÏÑ∏Ìûà ÏïåÎ†§Ï§ò ÏΩîÎìúÎ•º ÏûëÏÑ±Ìï¥Ï§ò.
ÏöîÏ≤≠ÌïòÏã† ‚ÄúÍ≤ÄÏùÄÏÉâ Î∞î(Í∞ÄÏö¥Îç∞ Ï†ïÎ†¨Îêú PDF ÎßÅÌÅ¨)‚ÄùÎäî .rsr-wrap ÏïàÏùò .rsr-runner Î∞îÎ°ú ÏïÑÎûòÏóê ÎÑ£ÏúºÏãúÎ©¥ Îê©ÎãàÎã§.
ÏïÑÏòà PDF ÎßÅÌÅ¨ÍπåÏßÄ Ìè¨Ìï®Ìï¥ÏÑú ÏΩîÎìú Ï†ÑÏ≤¥Î•º ÏßúÏ§ò. Í∏∞Ï°¥ ÏΩîÎìúÎäî ÏùºÏ†à Í±¥ÎìúÎ¶¨ÏßÄ ÎßêÍ≥† PDFÎßå ÎßÅÌÅ¨Îßå ÎßåÎì§Ïñ¥Ï£ºÎ©¥ Îèº. Í≤åÏûÑ Ï∞Ω Î∞ëÏóê Í∞ÄÏö¥Îç∞ Ï†ïÎ†¨Î°ú ÏûëÍ≤å PDF ÎßÅÌÅ¨ ÎßåÎì§Ïñ¥Ï£ºÎ©¥ Îèº.
ÏïÑÏòà PDF ÎßÅÌÅ¨ÍπåÏßÄ Ìè¨Ìï®Ìï¥ÏÑú ÏΩîÎìú Ï†ÑÏ≤¥Î•º ÏßúÏ§ò. Í∏∞Ï°¥ ÏΩîÎìúÎäî ÏùºÏ†à Í±¥ÎìúÎ¶¨ÏßÄ ÎßêÍ≥† PDFÎßå ÎßÅÌÅ¨Îßå ÎßåÎì§Ïñ¥Ï£ºÎ©¥ Îèº. Í≤åÏûÑ Ï∞Ω Î∞ëÏóê Í∞ÄÏö¥Îç∞ Ï†ïÎ†¨Î°ú ÏûëÍ≤å PDF ÎßÅÌÅ¨ ÎßåÎì§Ïñ¥Ï£ºÎ©¥ Îèº.

-->


<div style="max-width: 1000px; margin: 12px auto 20px;
            background: linear-gradient(120deg, #f6f8fa, #e6f0ff);
            border-left: 3px solid #3b82f6;
            border-radius: 12px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.06);
            padding: 6px 18px;
            font-family: 'Noto Sans', 'Noto Sans KR', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            color: #1e293b;
            line-height: 1.3;
            font-size: 0.8rem;
            text-align: left;">
  <h2 style="color: #1d4ed8;
             font-weight: 700;
             margin: 0 0 4px 0;
             font-size: 0.95rem;">
    üåç AI That Saves Lives
  </h2>
  <p style="margin: 0;">
    True life-saving AI isn‚Äôt the fastest ‚Äî it‚Äôs the one that never stops. It isn‚Äôt the most complex, but the most ethical, transparent, and repairable that truly serves humanity. Only AI that runs on simple solar power and old smartphones can reach those who need it most ‚Äî and keep them alive.
  </p>
</div>


<style>
  :root {
    --rsr-track-h: 120px;
    --rsr-radius: 14px;
    --rsr-ground: 10px;
  }
  #rsr-root { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans", sans-serif; color:#111; display:flex; flex-direction:column; align-items:center; gap:8px; padding:16px 10px; }
  .rsr-title { font-weight:800; font-size:18px; letter-spacing:.2px; margin:0; }
  .rsr-hud { display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-size:13px; color:#1a1a1a; }
  .rsr-badge { padding:4px 8px; border-radius:999px; border:1px solid #e5e7eb; background:#fafafa; }
  .rsr-temp strong{ font-weight:800; }
  .rsr-wrap { width:min(1100px, 100%); position:relative; }
  .rsr-runner { position:relative; width:100%; height:var(--rsr-track-h); border:1px solid #e5e7eb; border-radius:var(--rsr-radius); overflow:hidden; background:linear-gradient(180deg,#ffffff 0%, #f8fbff 100%); box-shadow:0 1px 0 rgba(0,0,0,.04), inset 0 -20px 40px rgba(0,0,0,.02); }
  #rsr-canvas { width:100%; height:100%; display:block; }
  .rsr-overlay { position:absolute; inset:0; background:rgba(255,255,255,.96); display:none; align-items:center; justify-content:center; text-align:center; padding:18px; }
  .rsr-overlay-inner{ max-width:560px; }
  .rsr-overlay h2{ margin:0 0 6px 0; font-size:18px; font-weight:800; }
  .rsr-overlay p{ margin:0 0 12px 0; font-size:14px; color:#333; }
  .rsr-btn { margin-top:8px; padding:9px 14px; border-radius:10px; border:1px solid #e5e7eb; background:#111827; color:#fff; font-weight:700; cursor:pointer; }
  .rsr-ground { position:absolute; left:0; right:0; bottom:0; height:var(--rsr-ground); background:repeating-linear-gradient(90deg,#b6c1cd 0 22px,#c5cfda 22px 44px); pointer-events:none; }
  @media (max-width:600px){ :root{ --rsr-track-h: 100px; } .rsr-hud{ font-size:12px; } }
</style>

<script>
(function(){
  'use strict';

  function onReady(fn){ if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', fn, {once:true}); else fn(); }

  onReady(()=>{
    document.title = 'Refugee Self-Reliance';

    // --- DOM scaffold ---
    const root = document.createElement('div');
    root.id = 'rsr-root';
    root.innerHTML = `
<div class="rsr-title">
  Refugee Self-Reliance Sovereign AI üåê
  <span style="color:#1e90ff;">
    This is an emoji-sized game (18 Kb) that contains a real-time micro offline AI.
  </span>
</div>


      <div class="rsr-hud">
        <span class="rsr-badge rsr-temp">üå°Ô∏è Climate Temperature <strong id="rsr-temp">1.5¬∞C</strong></span>
        <span class="rsr-badge">Score <strong id="rsr-score">0</strong></span>
        <span class="rsr-badge">Hunger <strong id=\"rsr-hunger\">25.0s<\/strong></span>
        <span class="rsr-badge">Press Space to jump</span>
        <span class="rsr-badge" id="rsr-ai-msg" style="display:none"></span>
      </div>
      <div class="rsr-wrap">
        <div class="rsr-runner">
          <canvas id="rsr-canvas"></canvas>
          <div class="rsr-ground"></div>
          <div class="rsr-overlay" id="rsr-overlay" role="dialog" aria-modal="true">
            <div class="rsr-overlay-inner">
              <h2>Refugee Self‚ÄëReliance at mcorpai.org</h2>
              <p>Free public‚Äëinterest partnerships available.</p>
              <p class="rsr-stats" style="margin-top:6px"></p>
              <button class="rsr-btn" id="rsr-retry" type="button">Retry</button>
            </div>
          </div>
        </div>

        <!-- PDF link (centered, small) placed directly under the game -->
        <div style="width:100%; display:flex; justify-content:center; margin-top:8px;">
          <a href="The_18KB_AI_Redefining_Intelligence_through_Ethics_and_Autonomy.pdf" target="_blank" rel="noopener" style="font-size:12px; color:#1f2937; text-decoration:underline;">
            The 18KB AI ‚Äî Redefining Intelligence through Ethics and Autonomy (PDF)
          </a>
        </div>
      </div>`;
    if(document.body?.prepend) document.body.prepend(root); else (document.body? document.body.insertBefore(root, document.body.firstChild||null) : document.documentElement.appendChild(root));

    // --- Refs ---
    const tempEl = document.getElementById('rsr-temp');
    const scoreEl = document.getElementById('rsr-score');
    const hungerEl = document.getElementById('rsr-hunger');
    const overlay = document.getElementById('rsr-overlay');
    const statsEl = overlay.querySelector('.rsr-stats');
    const retryBtn = document.getElementById('rsr-retry');
    const aiMsg = document.getElementById('rsr-ai-msg');

    // --- Canvas ---
    const canvas = document.getElementById('rsr-canvas');
    const ctx = canvas.getContext('2d');
    let W=0, H=0, DPR = Math.max(1, window.devicePixelRatio||1);

    // Tunables (~3 min target)
    const PLAYER_EMOJI = 'üò∫'; // change to 'üê±' if preferred
    let speedBase = 300; const gravity = 2200; const jumpV = -800;

    // State
    let running = true, speedMul = 1, groundY = 0; let player = null;
    const obstacles=[], foods=[], peaceBursts=[], missiles=[], explosions=[];
    let score = 0, temp = 1.5, hunger = 25.0;
    let lastSpawnObs=0, spawnObsEvery=1.4, lastSpawnFood=0, spawnFoodEvery=5.0;
    let lastJumpAt=-999, streak=0, foodsEaten=0; let startTime = performance.now();

    // Shelter
    const shelter = { active:false, t:0, dur:3.2 }; let nextShelterIn = rand(10,14); function scheduleShelter(){ nextShelterIn = rand(14,22);}  

    // --- AI persistence ---
    const AI_KEY='rsr_ai_policy_v2';
    // Arms: both Jump(J) and Missile(M) with decision thresholds (seconds to collision)
    const AI_ARMS=[
      {type:'J',t:0.34},{type:'J',t:0.30},{type:'J',t:0.26},{type:'J',t:0.22},{type:'J',t:0.18},
      {type:'M',t:0.34},{type:'M',t:0.28},{type:'M',t:0.24},{type:'M',t:0.20},{type:'M',t:0.16}
    ];
    let ai = loadPolicy();
    let aiActsLeft = chooseBudget(ai.prevSurvival||0); // 10..30
    let lastUserInput=-999; // sec
    let aiFireCooldown=0; // seconds between missiles
    let pendingEval = null; // {armIdx, t}

    function loadPolicy(){
      try{ const raw=localStorage.getItem(AI_KEY); if(raw){ const o=JSON.parse(raw); if(o && Array.isArray(o.arms) && o.arms.length===AI_ARMS.length) return o; } }catch(e){}
      return { arms: AI_ARMS.map((a,i)=>({ key:a.type+'-'+a.t, type:a.type, t:a.t, s:1, f:1 })), total:0, prevSurvival:0 };
    }
    function savePolicy(){ try{ localStorage.setItem(AI_KEY, JSON.stringify(ai)); }catch(e){} }

    function chooseBudget(prevSec){
      // Map last survival to assistance budget (10..30)
      if(prevSec<=30) return 30;
      if(prevSec<=60) return 26;
      if(prevSec<=90) return 22;
      if(prevSec<=120) return 18;
      if(prevSec<=180) return 14;
      return 10;
    }

    function pickArm(){
      const eps = ai.total < 60 ? 0.20 : 0.10;
      if(Math.random()<eps) return (Math.random()*AI_ARMS.length)|0;
      let best=-1, bestIdx=0;
      for(let i=0;i<ai.arms.length;i++){
        const a=ai.arms[i]; const mean=a.s/(a.s+a.f); if(mean>best){ best=mean; bestIdx=i; }
      }
      return bestIdx;
    }
    function updateArm(idx, success){ const a=ai.arms[idx]; if(!a) return; success? a.s++ : a.f++; ai.total++; savePolicy(); }

    function toastAI(){ aiMsg.textContent='A living example of ethical autonomy ‚Äî an AI that learns and decides for survival, entirely offline.'; aiMsg.style.display='inline-block'; clearTimeout(toastAI._t); toastAI._t=setTimeout(()=>aiMsg.style.display='none',1600); }

    function resize(){
      const wrap=canvas.parentElement||root; W=wrap.clientWidth|0; H=Math.max(90,Math.min(140,Math.floor(W*0.09))); DPR=Math.max(1,window.devicePixelRatio||1);
      canvas.width=Math.floor(W*DPR); canvas.height=Math.floor(H*DPR); canvas.style.width=W+'px'; canvas.style.height=H+'px'; ctx.setTransform(DPR,0,0,DPR,0,0);
      groundY=H-18; const size=Math.floor(H*0.36);
      if(!player){ player={ x:Math.floor(W*0.12), y:groundY-size, w:size*0.72, h:size, vy:0, size, emoji:'üò∫' }; }
      else { player.size=size; player.w=size*0.72; player.h=size; player.y=groundY-player.h; }
    }
    window.addEventListener('resize',resize); resize();

    function rand(min,max){ return Math.random()*(max-min)+min; }

    function spawnObstacle(){ const list=['üî´','üí£','üß®','ü™ñ','üß±','üõ°Ô∏è']; const em=list[(Math.random()*list.length)|0]; const hMul=Math.random()<0.08?1.1:1.0; const size=Math.floor(H*(0.24*hMul)); const w=Math.max(18,Math.floor(size*0.7)); const h=Math.max(22,size); const x=W+30; const y=groundY-h+4; obstacles.push({x,y,w,h,emoji:em,size:h,awarded:false}); }
    function spawnFood(){ const list=['üçû','ü•´','üçö','ü•ñ','üçé']; const em=list[(Math.random()*list.length)|0]; const size=Math.floor(H*0.28); const x=W+30; const lift=Math.min(40,H*0.3); const y=groundY-size-Math.random()*lift-6; foods.push({x,y,w:size*0.7,h:size,emoji:em,size}); }

    function rectsIntersect(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }
    function clamp(v,lo,hi){ return Math.max(lo,Math.min(hi,v)); }

    function die(){
      running=false; streak=0; overlay.style.display='flex'; const secs=((performance.now()-startTime)/1000).toFixed(1); statsEl.textContent=`Final temp ${temp.toFixed(1)}¬∞C ¬∑ Survival ${secs}s ¬∑ Food ${foodsEaten}`;
      if(pendingEval && (performance.now()*0.001 - pendingEval.t)<1.0){ updateArm(pendingEval.idx,false); pendingEval=null; }
      ai.prevSurvival=parseFloat(secs); savePolicy();
    }

    function reset(){
      running=true; obstacles.length=0; foods.length=0; peaceBursts.length=0; missiles.length=0; explosions.length=0;
      score=0; temp=1.5; hunger=20.0; speedMul=1; lastSpawnObs=0; spawnObsEvery=1.0; lastSpawnFood=0; spawnFoodEvery=6.0;
      player.vy=0; player.y=groundY-player.h; streak=0; foodsEaten=0; startTime=performance.now();
      shelter.active=false; shelter.t=0; scheduleShelter(); aiActsLeft=chooseBudget(ai.prevSurvival||0); aiFireCooldown=0; pendingEval=null; aiMsg.style.display='none';
      overlay.style.display='none'; lastTime=performance.now(); requestAnimationFrame(loop);
    }

    // Input
    window.addEventListener('keydown',(e)=>{ if(e.code==='Space'){ e.preventDefault(); if(!running) return; const onGround=player.y>=groundY-player.h-0.5; if(onGround){ player.vy=jumpV; lastJumpAt=performance.now()*0.001; lastUserInput=lastJumpAt; } } if(e.code==='KeyR'){ e.preventDefault(); reset(); } },{passive:false});
    canvas.addEventListener('pointerdown',()=>{ const onGround=player.y>=groundY-player.h-0.5; if(running && onGround){ player.vy=jumpV; lastJumpAt=performance.now()*0.001; lastUserInput=lastJumpAt; } });
    retryBtn.addEventListener('click',reset);

    // Peace bubble
    function burstPeace(){ peaceBursts.push({t:0,life:0.6,x:player.x+player.w*0.6,y:player.y-10}); if(peaceBursts.length>6) peaceBursts.shift(); }

    // Missile helper
    function fireMissile(){
      const size=Math.floor(H*0.22); const y=player.y+player.h - size - 4; missiles.push({ x:player.x+player.w*0.6, y, w:size*0.8, h:size, size, emoji:'üöÄ', vx: 1050, born: performance.now()*0.001 }); aiFireCooldown=0.35; }

    // AI controller
    function aiController(dt, speed){
      if(aiActsLeft<=0 || !running) return; const now=performance.now()*0.001; if(now-lastUserInput<0.12) return; if(aiFireCooldown>0){ aiFireCooldown-=dt; }
      // nearest obstacle
      let nearest=null, dist=Infinity; for(const o of obstacles){ const d=(o.x-(player.x+player.w)); if(d>0 && d<dist){ dist=d; nearest=o; } }
      if(!nearest) return; const ttc=dist/speed; const idx=pickArm(); const arm=ai.arms[idx]; const onGround=player.y>=groundY-player.h-0.5;
      if(arm.type==='J' && onGround && ttc<arm.t){ player.vy=jumpV; lastJumpAt=now; lastUserInput=now; aiActsLeft--; toastAI(); pendingEval={ idx, t: now }; }
      else if(arm.type==='M' && aiFireCooldown<=0 && ttc<arm.t){ fireMissile(); aiActsLeft--; toastAI(); pendingEval={ idx, t: now, missile:true }; }
      // mark success if survived ~0.9s after AI act and no failure was recorded
      if(pendingEval && (now-pendingEval.t)>0.9 && !pendingEval.waitHit){ updateArm(pendingEval.idx,true); pendingEval=null; }
    }

    // Loop
    let lastTime=performance.now();
    function loop(nowMs){
      const now=nowMs*0.001; let dt=(nowMs-lastTime)/1000; if(dt>0.05) dt=0.05; lastTime=nowMs; if(!running) return;

      // Shelter
      if(!shelter.active){ nextShelterIn-=dt; if(nextShelterIn<=0){ shelter.active=true; shelter.t=0; temp=clamp(temp-0.10,1.5,3.0);} } else { shelter.t+=dt; if(shelter.t>=shelter.dur){ shelter.active=false; scheduleShelter(); } }

      // Climate
      const baseRise=0.0032; temp=clamp(temp+(shelter.active?-0.020:baseRise)*dt*60,1.5,3.0); const diff=(temp-1.5)/1.5;

      // Speed
      const elapsed=(performance.now()-startTime)/1000; const ramp=Math.min(1,elapsed/12); speedMul=1+diff*0.4; const speed=(speedBase*(0.7+0.3*ramp))*speedMul;

      // Spawns
      spawnObsEvery=clamp(1.60 - diff*0.25, 0.90, 1.60); spawnFoodEvery=clamp(4.5 - diff*1.5, 2.0, 4.5);
      hunger-=dt; if(hunger<0) hunger=0; if(hunger===0){ die(); }

      player.vy+=gravity*dt; player.y+=player.vy*dt; if(player.y>groundY-player.h){ player.y=groundY-player.h; player.vy=0; }

      lastSpawnObs+=dt; if(!shelter.active && lastSpawnObs>=spawnObsEvery){ lastSpawnObs=0; spawnObstacle(); const allowDouble=elapsed>8; if(allowDouble && Math.random()<(0.02+diff*0.05)) setTimeout(spawnObstacle,Math.floor(rand(150,300))); }
      lastSpawnFood+=dt; if(lastSpawnFood>=spawnFoodEvery){ lastSpawnFood=0; spawnFood(); } if(hunger<12 && foods.length===0){ spawnFood(); }

      // AI decide before movement integration of entities
      aiController(dt, speed);

      // Move obstacles & collisions
      for(let i=obstacles.length-1;i>=0;i--){ const o=obstacles[i]; o.x-=speed*dt; if(rectsIntersect({x:player.x,y:player.y,w:player.w,h:player.h},{x:o.x,y:o.y,w:o.w,h:o.h})){ die(); }
        if(!o.awarded && o.x+o.w<player.x-player.w*0.1){ o.awarded=true; if(now-lastJumpAt<0.9){ streak=Math.min(streak+1,10); burstPeace(); } }
        if(o.x+o.w<-20) obstacles.splice(i,1); }

      for(let i=foods.length-1;i>=0;i--){ const f=foods[i]; f.x-=speed*dt*0.98; if(rectsIntersect({x:player.x,y:player.y,w:player.w,h:player.h},{x:f.x,y:f.y,w:f.w,h:f.h})){ foods.splice(i,1); score+=50; hunger=20.0; foodsEaten++; } else if(f.x+f.w<-20){ foods.splice(i,1);} }

      // Missiles
      for(let i=missiles.length-1;i>=0;i--){ const m=missiles[i]; m.x+= (m.vx + speed*0.2) * dt; // outrun obstacles
        // hit check
        let hit=false; for(let j=obstacles.length-1;j>=0;j--){ const o=obstacles[j]; if(rectsIntersect({x:m.x,y:m.y,w:m.w,h:m.h},{x:o.x,y:o.y,w:o.w,h:o.h})){ obstacles.splice(j,1); hit=true; break; } }
        if(hit){ explosions.push({x:m.x+ m.w*0.5, y:m.y+ m.h*0.4, t:0, life:0.35}); missiles.splice(i,1); if(pendingEval && pendingEval.missile){ updateArm(pendingEval.idx,true); pendingEval=null; } continue; }
        if(m.x > W+60){ missiles.splice(i,1); }
      }

      // Explosions fade
      for(let i=explosions.length-1;i>=0;i--){ const e=explosions[i]; e.t+=dt; if(e.t>e.life) explosions.splice(i,1); }

      // Score
      score += dt * (10 + 6 * diff) * speedMul + streak * dt;

      // Draw
      ctx.clearRect(0,0,W,H);
      if(shelter.active){ ctx.globalAlpha=0.12; ctx.fillStyle='#22c55e'; ctx.fillRect(0,0,W,H); ctx.globalAlpha=1; ctx.font="12px system-ui, -apple-system, 'Noto Sans'"; ctx.fillStyle='#14532d'; ctx.fillText('Shelter',10,16); }
      ctx.strokeStyle='#cdd6df'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,groundY+6); ctx.lineTo(W,groundY+6); ctx.stroke();
      for(const f of foods){ ctx.font=Math.floor(f.size)+"px 'Apple Color Emoji','Segoe UI Emoji','Noto Color Emoji',sans-serif"; ctx.textBaseline='bottom'; ctx.fillText(f.emoji,f.x,f.y+f.h); }
      for(const o of obstacles){ ctx.font=Math.floor(o.size)+"px 'Apple Color Emoji','Segoe UI Emoji','Noto Color Emoji',sans-serif"; ctx.textBaseline='bottom'; ctx.fillText(o.emoji,o.x,o.y+o.h); }
      // missiles
      for(const m of missiles){ ctx.font=Math.floor(m.size)+"px 'Apple Color Emoji','Segoe UI Emoji','Noto Color Emoji',sans-serif"; ctx.textBaseline='bottom'; ctx.fillText('üöÄ', m.x, m.y + m.h); }
      for(const e of explosions){ const a=1-(e.t/e.life); ctx.globalAlpha=Math.max(0,a); ctx.font=Math.floor(H*0.30)+"px 'Apple Color Emoji','Segoe UI Emoji','Noto Color Emoji',sans-serif"; ctx.fillText('üí•', e.x, e.y); ctx.globalAlpha=1; }
      // player
      ctx.font=Math.floor(player.size)+"px 'Apple Color Emoji','Segoe UI Emoji','Noto Color Emoji',sans-serif"; ctx.textBaseline='bottom'; ctx.fillText(player.emoji, player.x, player.y+player.h);
      // peace bubbles
      for(let i=peaceBursts.length-1;i>=0;i--){ const b=peaceBursts[i]; b.t+=dt; const a=1-(b.t/b.life); if(a<=0){ peaceBursts.splice(i,1); continue;} const y=b.y-(b.t*28); const text='Peace'; ctx.globalAlpha=Math.max(0,a*0.95); const sizeBoost=Math.min(4,streak*0.2); ctx.font=(11+sizeBoost)+"px system-ui, -apple-system, 'Noto Sans', sans-serif"; const tw=ctx.measureText(text).width+10; const tx=b.x, ty=y; ctx.fillStyle='#ffffff'; ctx.strokeStyle='#d9e0e7'; ctx.lineWidth=1; roundRect(ctx, tx, ty, tw, 18+sizeBoost*0.6, 9, true, true); ctx.fillStyle='#222'; ctx.fillText(text, tx+5, ty+13); ctx.globalAlpha=1; }

      // HUD
      tempEl.textContent= temp.toFixed(1)+'¬∞C'; hungerEl.textContent=hunger.toFixed(1)+'s'; scoreEl.textContent=Math.floor(score).toLocaleString();

      requestAnimationFrame(loop);
    }

    function roundRect(ctx,x,y,w,h,r,fill,stroke){ if(w<2*r) r=w/2; if(h<2*r) r=h/2; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill) ctx.fill(); if(stroke) ctx.stroke(); }

    // Self-tests
    console.groupCollapsed('RSR self-tests');
    console.assert(document.getElementById('rsr-root'),'root exists');
    console.assert(document.getElementById('rsr-canvas'),'canvas exists');
    console.assert(!!ctx,'2D context');
    console.assert(document.getElementById('rsr-overlay'),'overlay exists');
    console.assert(document.getElementById('rsr-retry'),'retry exists');
    console.assert(Array.isArray(AI_ARMS) && AI_ARMS.length>=6,'AI arms ready');
    console.assert(typeof aiActsLeft==='number' && aiActsLeft>=10 && aiActsLeft<=30,'AI budget 10..30');
    console.groupEnd();

    requestAnimationFrame(loop);

  });
})();

</script>

<!-- === AI game End === -->







<!-- Mouse Flight AI Simulator with Level System: embeddable block start -->

<style>
  #mouse-ai-wrapper {
    max-width: 260px;
    margin: 16px auto;
    padding: 12px;
    border-radius: 16px;
    box-shadow: 0 3px 12px rgba(0, 0, 0, 0.2);
    background: radial-gradient(circle at top, #020617 0, #020617 40%, #000 100%);
    color: #e5e7eb;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  #mouse-ai-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 6px;
  }

  #mouse-ai-title {
    font-size: 0.95rem;
    font-weight: 700;
    letter-spacing: 0.03em;
  }

  #mouse-ai-status {
    font-size: 0.7rem;
    opacity: 0.85;
    text-align: right;
  }

  #mouse-ai-hud {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.72rem;
    margin-bottom: 6px;
    gap: 6px;
  }

  #mouse-ai-hud-left,
  #mouse-ai-hud-right {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  #mouse-ai-ai-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 2px 6px;
    border-radius: 999px;
    font-size: 0.68rem;
    background: rgba(15, 23, 42, 0.7);
    border: 1px solid rgba(148, 163, 184, 0.8);
    transition: box-shadow 0.2s ease, transform 0.2s ease, border-color 0.2s ease;
  }

  #mouse-ai-ai-badge span {
    font-size: 0.7rem;
  }

  #mouse-ai-level-select {
    font-size: 0.68rem;
    padding: 1px 4px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.7);
    background: rgba(15, 23, 42, 0.9);
    color: #e5e7eb;
  }

  #mouse-ai-canvas {
    width: 100%;
    height: auto;
    display: block;
    border-radius: 10px;
    background: linear-gradient(180deg, #020617 0%, #020617 60%, #000 100%);
  }

  #mouse-ai-help {
    margin-top: 6px;
    font-size: 0.65rem;
    line-height: 1.4;
    color: #9ca3af;
  }

  #mouse-ai-help code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    background: rgba(15, 23, 42, 0.9);
    padding: 1px 3px;
    border-radius: 4px;
    font-size: 0.65rem;
  }

  #mouse-ai-container {
    position: relative;
  }

  #mouse-ai-overlay {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
  }

  #mouse-ai-overlay-message {
    padding: 6px 10px;
    border-radius: 999px;
    font-size: 0.7rem;
    font-weight: 600;
    background: rgba(15, 23, 42, 0.85);
    border: 1px solid rgba(248, 250, 252, 0.3);
    backdrop-filter: blur(8px);
    box-shadow: 0 4px 14px rgba(0, 0, 0, 0.5);
    text-align: center;
  }

  .mouse-ai-auto #mouse-ai-ai-badge {
    border-color: rgba(34, 197, 94, 0.9);
    box-shadow: 0 0 8px rgba(34, 197, 94, 0.7);
  }

  .mouse-ai-human #mouse-ai-ai-badge {
    border-color: rgba(249, 115, 22, 0.9);
    box-shadow: 0 0 6px rgba(249, 115, 22, 0.7);
  }

  .mouse-ai-suggest #mouse-ai-ai-badge {
    animation: mouse-ai-pulse 0.9s infinite alternate;
  }

  @keyframes mouse-ai-pulse {
    from {
      opacity: 0.85;
      transform: translateY(-1px) scale(1.0);
    }
    to {
      opacity: 1;
      transform: translateY(-2px) scale(1.03);
    }
  }
</style>

<section id="mouse-ai-wrapper">
  <header id="mouse-ai-header">
    <div id="mouse-ai-title">Mouse Flight AI Simulator üê≠</div>
    <div id="mouse-ai-status">
      <div>Distance: <span id="mouse-ai-distance">0</span> m</div>
      <div>Best: <span id="mouse-ai-best">0</span> m</div>
    </div>
  </header>

  <div id="mouse-ai-hud">
    <div id="mouse-ai-hud-left">
      <div>Mode: <span id="mouse-ai-mode-label">AI autopilot</span></div>
      <div>Episodes: <span id="mouse-ai-episodes">0</span></div>
    </div>
    <div id="mouse-ai-hud-right">
      <div id="mouse-ai-ai-badge">
        <span id="mouse-ai-ai-face">ü§ñ</span>
        <span id="mouse-ai-ai-info">Lv.1 ¬∑ Trust 0%</span>
      </div>
      <div>
        Learning:
        <select id="mouse-ai-level-select">
          <option value="1">Lv.1 ‚Äì Fresh (0% learning)</option>
          <option value="2">Lv.2 ‚Äì Cautious learner</option>
          <option value="3">Lv.3 ‚Äì Trained</option>
          <option value="4">Lv.4 ‚Äì Expert</option>
          <option value="5">Lv.5 ‚Äì Master (max)</option>
        </select>
      </div>
    </div>
  </div>

  <div id="mouse-ai-container">
    <canvas id="mouse-ai-canvas" width="240" height="360"></canvas>
    <div id="mouse-ai-overlay">
      <div id="mouse-ai-overlay-message">
        Default: AI mouse flies automatically.<br>
        Space / left click: switch to human control.
      </div>
    </div>
  </div>

  <div id="mouse-ai-help">
    <div>¬∑ The mouse (üê≠) flies forward and tries to dodge incoming cats (üê±).</div>
    <div>¬∑ By default the AI controls the mouse and learns from every episode.</div>
    <div>¬∑ Press <code>Space</code> or <code>left click</code> to take over. The AI stops acting until the next round.</div>
    <div>¬∑ Use the <strong>AI Learning</strong> level (Lv.1‚ÄìLv.5) to reset and control how strong the learning is.</div>
  </div>
</section>

<script>
(function () {
  const canvas = document.getElementById("mouse-ai-canvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");

  const wrapper = document.getElementById("mouse-ai-wrapper");
  const distanceEl = document.getElementById("mouse-ai-distance");
  const bestEl = document.getElementById("mouse-ai-best");
  const modeLabelEl = document.getElementById("mouse-ai-mode-label");
  const episodesEl = document.getElementById("mouse-ai-episodes");
  const aiFaceEl = document.getElementById("mouse-ai-ai-face");
  const aiInfoEl = document.getElementById("mouse-ai-ai-info");
  const overlayEl = document.getElementById("mouse-ai-overlay");
  const overlayMessageEl = document.getElementById("mouse-ai-overlay-message");
  const levelSelect = document.getElementById("mouse-ai-level-select");

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  const GRAVITY = 0.0024;
  const JUMP_VELOCITY = -0.9;
  const BASE_SCROLL_SPEED = 0.16;
  const MAX_DT = 50; // ms

  const ENEMY_SPAWN_BASE = 900;
  const ENEMY_SPAWN_VAR = 650;
  const AI_STORAGE_KEY = "mouse_flight_ai_brain_v3";
  const BEST_DISTANCE_KEY = "mouse_flight_best_distance_v3";
  const MAX_LEVEL = 5;

  let lastTime = 0;
  let simTime = 0;
  let distance = 0;
  let bestDistance = Number(localStorage.getItem(BEST_DISTANCE_KEY) || "0");
  let gameOver = false;

  const player = {
    x: WIDTH * 0.2,
    y: HEIGHT * 0.5,
    vy: 0,
    radius: 12,
  };

  let enemies = [];
  let enemySpawnTimer = 0;
  let difficultyLevel = 0;

  let autopilot = true;
  let lastJumpTime = 0;
  let decisionHistory = [];
  let humanPendingJump = false;
  const MAX_HISTORY = 32;

  let overlayTimer = null;

  const aiBrain = loadBrain();
  let aiLevel = aiBrain.currentLevel || 1;
  if (aiLevel < 1 || aiLevel > MAX_LEVEL) aiLevel = 1;
  aiBrain.currentLevel = aiLevel;

  distanceEl.textContent = "0";
  bestEl.textContent = Math.floor(bestDistance).toString();
  updateAIIndicators();
  updateModeIndicators();
  if (levelSelect) levelSelect.value = String(aiLevel);
  showOverlayMessage(
    "Default: AI mouse flies automatically. Space or left click to take control."
  );
  resetGame();

  // ---------- Persistence ----------

  function loadBrain() {
    try {
      const raw = localStorage.getItem(AI_STORAGE_KEY);
      if (!raw) {
        return { stats: {}, totalSuccess: 0, totalFail: 0, episodes: 0, currentLevel: 1 };
      }
      const parsed = JSON.parse(raw);
      return {
        stats: parsed.stats || {},
        totalSuccess: parsed.totalSuccess || 0,
        totalFail: parsed.totalFail || 0,
        episodes: parsed.episodes || 0,
        currentLevel: parsed.currentLevel || 1,
      };
    } catch (e) {
      console.warn("AI brain load failed", e);
      return { stats: {}, totalSuccess: 0, totalFail: 0, episodes: 0, currentLevel: 1 };
    }
  }

  function saveBrain() {
    try {
      localStorage.setItem(
        AI_STORAGE_KEY,
        JSON.stringify({
          stats: aiBrain.stats,
          totalSuccess: aiBrain.totalSuccess,
          totalFail: aiBrain.totalFail,
          episodes: aiBrain.episodes,
          currentLevel: aiLevel,
        })
      );
    } catch (e) {
      console.warn("AI brain save failed", e);
    }
  }

  // ---------- UI helpers ----------

  function showOverlayMessage(text, durationMs) {
    if (!overlayEl) return;
    overlayMessageEl.textContent = text;
    overlayEl.style.display = "flex";
    if (overlayTimer) clearTimeout(overlayTimer);
    overlayTimer = setTimeout(function () {
      overlayEl.style.display = "none";
    }, durationMs || 10000); // default 10 seconds
  }

  function updateAIIndicators() {
    const totalS = aiBrain.totalSuccess || 0;
    const totalF = aiBrain.totalFail || 0;
    const total = totalS + totalF;
    let trust = 0;
    if (total > 0) trust = Math.round((totalS / total) * 100);

    let face = "ü§ñ";
    if (aiLevel >= 5) face = "üß†";
    else if (aiLevel === 4) face = "üòº";
    else if (aiLevel === 3) face = "üôÇ";
    else face = "ü§ñ";

    aiFaceEl.textContent = face;
    aiInfoEl.textContent = "Lv." + aiLevel + " ¬∑ Trust " + trust + "%";
    episodesEl.textContent = (aiBrain.episodes || 0).toString();

    if (levelSelect && levelSelect.value !== String(aiLevel)) {
      levelSelect.value = String(aiLevel);
    }
  }

  function updateModeIndicators() {
    if (autopilot && !gameOver) {
      modeLabelEl.textContent = "AI autopilot";
      wrapper.classList.add("mouse-ai-auto");
      wrapper.classList.remove("mouse-ai-human");
    } else if (!gameOver) {
      modeLabelEl.textContent = "Human control";
      wrapper.classList.remove("mouse-ai-auto");
      wrapper.classList.add("mouse-ai-human");
    } else {
      modeLabelEl.textContent = "Game over";
      wrapper.classList.remove("mouse-ai-auto");
      wrapper.classList.remove("mouse-ai-human");
    }
  }

  function applyManualLevel(levelValue) {
    const lvl = Number(levelValue);
    if (!Number.isFinite(lvl) || lvl < 1 || lvl > MAX_LEVEL) return;

    // Reset all learned experience
    aiBrain.stats = {};
    aiBrain.totalSuccess = 0;
    aiBrain.totalFail = 0;
    aiBrain.episodes = 0;
    aiLevel = lvl;
    saveBrain();
    updateAIIndicators();
    resetGame();
    showOverlayMessage(
      "AI learning level set to Lv." +
        lvl +
        ". Experience has been reset and a new training phase begins."
    );
  }

  if (levelSelect) {
    levelSelect.addEventListener("change", function (e) {
      applyManualLevel(e.target.value);
    });
  }

  // ---------- Game reset ----------

  function resetGame() {
    enemies = [];
    enemySpawnTimer = 600;
    distance = 0;
    difficultyLevel = 0;
    simTime = 0;
    decisionHistory = [];
    humanPendingJump = false;
    lastJumpTime = 0;

    player.x = WIDTH * 0.2;
    player.y = HEIGHT * 0.5;
    player.vy = 0;
    distanceEl.textContent = "0";

    gameOver = false;
    autopilot = true; // new round always starts with AI control
    updateModeIndicators();
  }

  // ---------- World / enemies ----------

  function spawnEnemy() {
    const y = 40 + Math.random() * (HEIGHT - 80);
    const speed = BASE_SCROLL_SPEED + 0.035 * difficultyLevel + Math.random() * 0.05;
    enemies.push({
      x: WIDTH + 40,
      y: y,
      vx: speed,
      passed: false,
    });
  }

  function updateDifficulty() {
    const newLevel = Math.floor(distance / 300);
    if (newLevel > difficultyLevel) difficultyLevel = newLevel;
  }

  function getNearestThreat() {
    let nearest = null;
    let minDx = Infinity;
    for (const e of enemies) {
      const dx = e.x - player.x;
      if (dx >= 0 && dx < minDx) {
        minDx = dx;
        nearest = e;
      }
    }
    return nearest;
  }

  // ---------- State & RL ----------

  function makeStateKey() {
    const threat = getNearestThreat();
    if (!threat) return "none";
    const dx = threat.x - player.x;
    const dy = threat.y - player.y;

    let distBucket = 2;
    if (dx < WIDTH * 0.25) distBucket = 0;
    else if (dx < WIDTH * 0.5) distBucket = 1;

    let dyBucket = 1;
    if (dy < -20) dyBucket = 0;
    else if (dy > 20) dyBucket = 2;

    return dyBucket + ":" + distBucket;
  }

  function ensureState(stateKey) {
    const stats = (aiBrain.stats[stateKey] = aiBrain.stats[stateKey] || {
      jump: { s: 0, f: 0 },
      stay: { s: 0, f: 0 },
    });
    return stats;
  }

  function getActionStats(stateKey, action) {
    const stats = ensureState(stateKey);
    return stats[action];
  }

  function rlPolicy(stateKey) {
    if (stateKey === "none") return "stay";

    // Learning strength: higher level => lower exploration
    const epsLevelPart = 0.30 - (aiLevel - 1) * 0.05; // Lv1:0.30, Lv5:0.10
    const eps = Math.max(0.04, epsLevelPart);

    if (Math.random() < eps) {
      return Math.random() < 0.5 ? "jump" : "stay";
    }

    const js = getActionStats(stateKey, "jump");
    const ss = getActionStats(stateKey, "stay");
    const jCount = js.s + js.f;
    const sCount = ss.s + ss.f;
    const jRate = jCount > 0 ? js.s / jCount : 0.5;
    const sRate = sCount > 0 ? ss.s / sCount : 0.5;

    if (jRate > sRate) return "jump";
    if (sRate > jRate) return "stay";
    return Math.random() < 0.5 ? "jump" : "stay";
  }

  function recordDecision(stateKey, action) {
    decisionHistory.push({ stateKey: stateKey, action: action });
    if (decisionHistory.length > MAX_HISTORY) decisionHistory.shift();
  }

  function updateAutoLevel() {
    const s = aiBrain.totalSuccess || 0;
    let target = 1;
    if (s > 20) target = 2;
    if (s > 60) target = 3;
    if (s > 140) target = 4;
    if (s > 260) target = 5;

    if (target > aiLevel) {
      aiLevel = target;
      saveBrain();
      updateAIIndicators();
      showOverlayMessage("AI has improved its learning to Lv." + aiLevel + ".");
    } else {
      saveBrain();
      updateAIIndicators();
    }
  }

  function rewardHistory(kind) {
    if (decisionHistory.length === 0) return;
    const isSuccess = kind === "success";
    for (const d of decisionHistory) {
      const stats = getActionStats(d.stateKey, d.action);
      if (isSuccess) {
        stats.s += 1;
        aiBrain.totalSuccess += 1;
      } else {
        stats.f += 1;
        aiBrain.totalFail += 1;
      }
    }
    if (!isSuccess) {
      aiBrain.episodes += 1;
    }
    updateAutoLevel();
  }

  function simulateSafety(action) {
    const nearEnemies = enemies.filter(function (e) {
      return e.x > player.x - 10 && e.x < player.x + 220;
    });
    if (nearEnemies.length === 0) return 9999;

    const horizon = 600; // ms
    const step = 40; // ms
    let y = player.y;
    let vy = player.vy;
    const top = 30;
    const bottom = HEIGHT - 30;
    let minClearance = Infinity;

    for (let t = 0; t <= horizon; t += step) {
      if (t === 0 && action === "jump") {
        vy = JUMP_VELOCITY;
      }
      vy += GRAVITY * step;
      y += vy * step;
      if (y < top) {
        y = top;
        vy = 0;
      }
      if (y > bottom) {
        y = bottom;
        vy = 0;
      }
      for (const e of nearEnemies) {
        const ex = e.x - e.vx * t;
        const ey = e.y;
        const dx = ex - player.x;
        const dy = ey - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < minClearance) minClearance = dist;
      }
    }
    return minClearance;
  }

  function aiStep() {
    const now = simTime;
    const threat = getNearestThreat();

    if (!threat) {
      const center = HEIGHT * 0.5;
      const diff = player.y - center;
      if (diff > 30 && now - lastJumpTime > 220) {
        player.vy = JUMP_VELOCITY;
        lastJumpTime = now;
        recordDecision("none", "jump");
      } else {
        recordDecision("none", "stay");
      }
      wrapper.classList.remove("mouse-ai-suggest");
      return;
    }

    const stateKey = makeStateKey();
    const safetyStay = simulateSafety("stay");
    const safetyJump = simulateSafety("jump");
    const SAFETY_MARGIN = 8;
    let action;

    if (safetyJump === 9999 && safetyStay === 9999) {
      action = rlPolicy(stateKey);
    } else {
      const diff = safetyJump - safetyStay;
      if (Math.abs(diff) > SAFETY_MARGIN) {
        action = diff > 0 ? "jump" : "stay";
      } else {
        action = rlPolicy(stateKey);
      }

      if (diff > SAFETY_MARGIN && safetyJump < 9999) {
        wrapper.classList.add("mouse-ai-suggest");
      } else {
        wrapper.classList.remove("mouse-ai-suggest");
      }
    }

    if (action === "jump" && now - lastJumpTime > 180) {
      player.vy = JUMP_VELOCITY;
      lastJumpTime = now;
    }

    recordDecision(stateKey, action);
  }

  function humanObserveStep() {
    const stateKey = makeStateKey();
    const action = humanPendingJump ? "jump" : "stay";
    recordDecision(stateKey, action);
    humanPendingJump = false;
  }

  // ---------- Collisions ----------

  function collideCircles(ax, ay, ar, bx, by, br) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy < (ar + br) * (ar + br);
  }

  function checkCollisions() {
    for (const e of enemies) {
      if (collideCircles(player.x, player.y, player.radius, e.x, e.y, 12)) {
        return true;
      }
    }
    return false;
  }

  function handleGameOver() {
    gameOver = true;
    wrapper.classList.remove("mouse-ai-suggest");
    updateModeIndicators();
    if (distance > bestDistance) {
      bestDistance = distance;
      localStorage.setItem(BEST_DISTANCE_KEY, String(Math.floor(bestDistance)));
      bestEl.textContent = Math.floor(bestDistance).toString();
    }
    showOverlayMessage(
      "The mouse crashed. AI has learned from this episode. Press Space or click to start a new round."
    );
  }

  // ---------- Game loop ----------

  function update(dt) {
    if (gameOver) return;

    simTime += dt;

    if (autopilot) {
      aiStep();
    } else {
      humanObserveStep();
    }

    player.vy += GRAVITY * dt;
    player.y += player.vy * dt;

    const top = 30;
    const bottom = HEIGHT - 30;
    if (player.y < top) {
      player.y = top;
      player.vy = 0;
    }
    if (player.y > bottom) {
      player.y = bottom;
      player.vy = 0;
    }

    distance += BASE_SCROLL_SPEED * dt * 0.06;
    distanceEl.textContent = Math.floor(distance).toString();
    updateDifficulty();

    enemySpawnTimer -= dt;
    if (enemySpawnTimer <= 0) {
      spawnEnemy();
      const base = ENEMY_SPAWN_BASE - difficultyLevel * 60;
      enemySpawnTimer = Math.max(320, base) + Math.random() * ENEMY_SPAWN_VAR;
    }

    for (const e of enemies) {
      e.x -= e.vx * dt;
      if (!e.passed && e.x < player.x) {
        e.passed = true;
        rewardHistory("success");
      }
    }
    enemies = enemies.filter(function (e) {
      return e.x > -40;
    });

    if (checkCollisions()) {
      rewardHistory("fail");
      handleGameOver();
    }
  }

  function drawBackground() {
    const grd = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    grd.addColorStop(0, "#020617");
    grd.addColorStop(0.5, "#020617");
    grd.addColorStop(1, "#000000");
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    const starsCount = 18;
    ctx.fillStyle = "rgba(248, 250, 252, 0.28)";
    for (let i = 0; i < starsCount; i++) {
      const x = ((i * 53 + Math.floor(distance)) % WIDTH) | 0;
      const y = (i * 31) % HEIGHT;
      ctx.fillRect(x, y, 1, 1);
    }

    ctx.fillStyle = "rgba(15, 23, 42, 0.9)";
    ctx.fillRect(0, HEIGHT - 28, WIDTH, 28);
  }

  function drawEnemies() {
    ctx.font = "20px system-ui, Apple Color Emoji, Segoe UI Emoji";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    for (const e of enemies) {
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.fillText("üê±", 0, 0);
      ctx.restore();
    }
  }

  function drawPlayer() {
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.font = "22px system-ui, Apple Color Emoji, Segoe UI Emoji";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("üê≠", 0, 0);
    ctx.restore();
  }

  function render() {
    drawBackground();
    drawEnemies();
    drawPlayer();
  }

  function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    let dt = timestamp - lastTime;
    lastTime = timestamp;
    if (dt > MAX_DT) dt = MAX_DT;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  // ---------- Input ----------

  function humanTakeOver() {
    if (gameOver) {
      resetGame();
      showOverlayMessage("New round. AI autopilot is active again.");
      return;
    }
    if (autopilot) {
      autopilot = false;
      updateModeIndicators();
      showOverlayMessage("Human control enabled. AI is now observing your play.");
    }
  }

  function onKeyDown(e) {
    if (e.code === "Space") {
      e.preventDefault();
      if (gameOver) {
        humanTakeOver();
      } else {
        humanTakeOver();
        player.vy = JUMP_VELOCITY;
        humanPendingJump = true;
      }
    }
  }

  function onMouseDown(e) {
    if (e.button === 0) {
      if (gameOver) {
        humanTakeOver();
      } else {
        humanTakeOver();
        player.vy = JUMP_VELOCITY;
        humanPendingJump = true;
      }
    }
  }

  canvas.addEventListener("mousedown", onMouseDown);
  canvas.addEventListener("contextmenu", function (e) {
    e.preventDefault();
  });
  window.addEventListener("keydown", onKeyDown);

  requestAnimationFrame(loop);
})();
</script>

<!-- Mouse Flight AI Simulator with Level System: embeddable block end -->

